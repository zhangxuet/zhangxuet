<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小程序使用vant-weapp</title>
    <url>/2020/04/22/wxprogram/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8vant-weapp/</url>
    <content><![CDATA[<h1 id="小程序使用vant-weapp"><a href="#小程序使用vant-weapp" class="headerlink" title="小程序使用vant-weapp"></a>小程序使用vant-weapp</h1><h2 id="原生使用-例如checkbox"><a href="#原生使用-例如checkbox" class="headerlink" title="原生使用(例如checkbox)"></a>原生使用(例如checkbox)</h2><p>官网下载vant到本地</p>
<pre><code>npm i vant-weapp -S --production</code></pre><p>将node-modules中的vant/dist文件下的内容copy到static/vant(static/vant/dist)里面</p>
<pre><code>  &quot;usingComponents&quot;: {
    &quot;van-button&quot;: &quot;/static/vant/dist/button/index&quot;, 
    &quot;van-rate&quot;:&quot;/static/vant/dist/rate/index&quot;,
    &quot;van-cell&quot;: &quot;/static/vant/dist/cell/index&quot;,
    &quot;van-cell-group&quot;: &quot;/static/vant/dist/cell-group/index&quot;,
    &quot;van-checkbox&quot;: &quot;/static/vant/dist/checkbox/index&quot;,
    &quot;van-checkbox-group&quot;: &quot;/static/vant/dist/checkbox-group/index&quot;
  }</code></pre><pre><code class="html">&lt;van-checkbox-group value=&quot;{{ result }}&quot; bind:change=&quot;onChange&quot;&gt;
  &lt;van-cell-group &gt;
    &lt;van-cell
      wx:for=&quot;{{ list }}&quot;
      wx:key=&quot;index&quot;
      title=&quot;复选框 {{ item }}&quot;
      value-class=&quot;value-class&quot;
      clickable
      data-index=&quot;{{ index }}&quot;
      bind:click=&quot;toggle&quot;
    &gt;
      &lt;van-checkbox catch:tap=&quot;noop&quot; class=&quot;checkboxes-{{ index }}&quot; name=&quot;{{ item }}&quot; /&gt;
    &lt;/van-cell&gt;
  &lt;/van-cell-group&gt;
&lt;/van-checkbox-group&gt;

.value-class {
  flex: none !important;
}</code></pre>
<pre><code class="js">Page({
  data: {
    list: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
    result: [&#39;a&#39;, &#39;b&#39;]
  },
  onChange(event) {
    this.setData({
      result: event.detail    /////////////////////////////////////////
    });
  },
  toggle(event) {
    const { index } = event.currentTarget.dataset; 
    const checkbox = this.selectComponent(`.checkboxes-${index}`);  ///////////////////////////
    checkbox.toggle();
  },

  noop() {}
});</code></pre>
<h2 id="mpvue使用"><a href="#mpvue使用" class="headerlink" title="mpvue使用"></a>mpvue使用</h2><pre><code class="html">&lt;van-checkbox-group :value=&quot;result&quot; @change=&quot;onChange&quot;&gt;
  &lt;van-cell-group &gt;
    &lt;van-cell
        v-for=&quot;(item, index) in list&quot;
        :key=&quot;index&quot;
        :title=&quot;&#39;复选框&#39;+item&quot;
        value-class=&quot;value-class&quot;
        clickable
        :data-index=&quot;index&quot;
        @click=&quot;toggle($event, item)&quot;
        &gt;
        &lt;van-checkbox @tap=&quot;noop&quot; :class=&quot;&#39;checkboxes-&#39;+index&quot; :name=&quot;item&quot; /&gt;
    &lt;/van-cell&gt;
  &lt;/van-cell-group&gt;
&lt;/van-checkbox-group&gt;</code></pre>
<pre><code>data () {
    return: {
        list: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
          result: [&#39;a&#39;, &#39;b&#39;],
    }
}</code></pre><pre><code class="js">onChange (event) {
    this.result = event.mp.detail     //////////////////////////////////////////////
},
toggle (event, item) {
    const { index } = event.currentTarget.dataset
    const checkbox = this.$mp.page.selectComponent(`.checkboxes-${index}`)    ///////////////
    checkbox.toggle()
    console.log(item)
},
noop () {}</code></pre>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>element</title>
    <url>/2020/04/20/vue/element/</url>
    <content><![CDATA[<h1 id="element弹窗关闭清除表单验证内容"><a href="#element弹窗关闭清除表单验证内容" class="headerlink" title="element弹窗关闭清除表单验证内容"></a>element弹窗关闭清除表单验证内容</h1><pre><code class="js">&lt;el-dialog
    title=&quot;国家&quot;
    :visible.sync=&quot;DialogVisible&quot;
    width=&quot;50%&quot;
    class=&quot;dialog&quot;
    @close=&quot;handleCloseNew&quot;         //  关闭触发事件
    center&gt;
    &lt;el-form :rules=&quot;ruleForm&quot; :model=&quot;countryForm&quot; ref=&quot;countryForm&quot;&gt;  // 一定要有ref
</code></pre>
<pre><code class="js">// 关闭新增弹窗
handleCloseNew () {
    if(this.$refs.countryForm){
        this.$refs.countryForm.clearValidate()   // 清除验证内容
    }
},</code></pre>
<h1 id="表格居中"><a href="#表格居中" class="headerlink" title="表格居中"></a>表格居中</h1><pre><code>&lt;el-table
    :data=&quot;countryMsg&quot;
    style=&quot;width: 98.5%&quot;
    border
    :cell-style=&quot;cellStyle&quot;
    :header-cell-style=&quot;rowClass&quot;
    &gt;</code></pre><pre><code>// 居中
rowClass () {
    return &#39;text-align: center; background: #017fba; color: #fff&#39;
},
cellStyle () {
    return &quot;text-align: center&quot;
}</code></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>element</tag>
      </tags>
  </entry>
  <entry>
    <title>频道管理</title>
    <url>/2020/04/15/vue/%E9%A2%91%E9%81%93%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="准备组件"><a href="#准备组件" class="headerlink" title="准备组件"></a>准备组件</h1><p>使用组件：<code>src/views/home/index.vue</code></p>
<pre><code class="js">showEditChannel: false</code></pre>
<pre><code class="html">&lt;channel-edit v-model=&quot;showEditChannel&quot;&gt;&lt;/channel-edit&gt;</code></pre>
<p>组件结构：<code>src/views/home/components/channel-edit.vue</code></p>
<p>数据：</p>
<pre><code class="js"> props: {
    value: {
      type: Boolean,
      default: false
    }
 }            </code></pre>
<pre><code class="js">  data () {
    return {
      // 正在编辑我的频道
      editing: false
    }
</code></pre>
<h1 id="渲染我的频道"><a href="#渲染我的频道" class="headerlink" title="渲染我的频道"></a>渲染我的频道</h1><ul>
<li>使用父组件数据  <code>src/views/home/index.vue</code><ul>
<li>我的频道列表</li>
<li>当前激活频道</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;channel-edit :channels=&quot;channels&quot; :activeIndex=&quot;activeIndex&quot;&gt;&lt;/channel-edit&gt;</code></pre>
<pre><code class="js">data () {
  return {
     activeIndex: 0,
     channels: []
  }
}  </code></pre>
<ul>
<li>接收父组件数据  <code>src/views/home/components/channel-edit.vue</code></li>
</ul>
<pre><code class="js">    // 复杂数据类型
    channels: {
      type: Array,
      // 语法规范：通过一个函数的返回值来指定默认值
      default: () =&gt; []
    },
    // 激活频道索引
    activeIndex: {
      type: Number,
      default: 0
    }</code></pre>
<h1 id="渲染可选频道"><a href="#渲染可选频道" class="headerlink" title="渲染可选频道"></a>渲染可选频道</h1><ul>
<li>获取所有频道API <code>src/api/channel.js</code></li>
</ul>
<pre><code class="js">/**
 * 获取全部频道
 */
export const getAllChannels = () =&gt; {
  return request(&#39;/app/v1_0/channels&#39;, &#39;get&#39;)
}
</code></pre>
<ul>
<li>调用API</li>
</ul>
<pre><code class="js">methods: {
  async getAllChannels () {
    const data = await getAllChannels()
    this.allChannels = data.channels
  }                    
}</code></pre>
<pre><code class="js">  created () {
    this.getAllChannels()
  },</code></pre>
<ul>
<li>可选频道 = 全部频道 - 我的频道</li>
</ul>
<pre><code class="js">computed: {
    optionalChannels () {
      // 可选频道 = 全部频道 - 我的频道
      // 可选频道:遍历全部频道，拿着每一项去我的频道当中去对比，如果一样忽略，如果不一样，放到可选频道中。
      // Array.filter() 数组提供的遍历函数，当条件（回调函数的返回值）为真时候，把对应遍历的选项，放在新数组中。
      // 如果没找呢  findIndex()值  -1
      return this.allChannels.filter(item =&gt; this.channels.findIndex(myItem =&gt; myItem.id === item.id) === -1)
    }
  },</code></pre>
<h1 id="点击进入频道"><a href="#点击进入频道" class="headerlink" title="点击进入频道"></a>点击进入频道</h1><pre><code class="html">&lt;span class=&quot;f12&quot; @click=&quot;enterChannel(i)&quot; </code></pre>
<pre><code class="js">    enterChannel (index) {
      // 关闭 当前组件                                    
      this.$emit(&#39;input&#39;, false)
      // 把现在的index设置给父组件activeIndex即可
      // 给自己绑定一个自定义事件  触发这个事件传递index 让父组件来改                           
      this.$emit(&#39;update&#39;, index)
    },</code></pre>
<pre><code class="html">    &lt;edit-channel
      v-model=&quot;showEditChannel&quot;
      :channels=&quot;channels&quot;
      @update=&quot;activeIndex=$event&quot;
      :activeIndex=&quot;activeIndex&quot;&gt;
    &lt;/edit-channel&gt;</code></pre>
<p>可以简写：sync 修饰符</p>
<pre><code class="diff">    enterChannel (index) {
      this.$emit(&#39;input&#39;, false)
-     this.$emit(&#39;update&#39;, index)
+     this.$emit(&#39;update:activeIndex&#39;, index)
    },</code></pre>
<pre><code class="diff">    &lt;edit-channel
      v-model=&quot;showEditChannel&quot;
      :channels=&quot;channels&quot;
-      @update=&quot;activeIndex=$event&quot;
-      :activeIndex=&quot;activeIndex&quot;&gt;
+      :activeIndex.sync=&quot;activeIndex&quot;&gt;
    &lt;/edit-channel&gt;</code></pre>
<ul>
<li>sync 背后绑定的是 update 事件</li>
</ul>
<h1 id="重构我的频道API"><a href="#重构我的频道API" class="headerlink" title="重构我的频道API"></a>重构我的频道API</h1><ul>
<li>兼容本地存储</li>
</ul>
<pre><code class="js">const CHANNEL_KEY = &#39;channels&#39;
 * 获取我的频道信息（如果没登录，获取的是后台设置的默认频道列表）
 */
// 3.1 未登录 且  已存储  业务：获取本地存储数据
// 3.2 未登录 且  未存储  业务：获取默认数据，且进行本地存储。
// 4. 约定（不管任何情况，返回值是一个promise对象，获取我的频道（数据格式一致和后台返回的））
export const getMyChannels = () =&gt; {
  return new Promise(async (resolve, reject) =&gt; {
    const { user } = store.state
    if (user.token) {
      // 登录
      const data = await request(&#39;/app/v1_0/user/channels&#39;, &#39;get&#39;)
      resolve(data)
    } else {
      // 未登录
      const channelsStr = window.localStorage.getItem(CHANNEL_KEY)
      if (channelsStr) {
        // 已存储
        const channelsJson = JSON.parse(channelsStr)
        resolve({ channels: channelsJson })
      } else {
        // 未存储
        const data = await request(&#39;/app/v1_0/user/channels&#39;, &#39;get&#39;)
        // 存储
        window.localStorage.setItem(CHANNEL_KEY, JSON.stringify(data.channels))
        resolve(data)
      }
    }
  })
}</code></pre>
<ul>
<li><p>注意：</p>
<ul>
<li>本地存储，返回数据格式，和后端保存一致。</li>
</ul>
</li>
</ul>
<h1 id="删除我的频道API"><a href="#删除我的频道API" class="headerlink" title="删除我的频道API"></a>删除我的频道API</h1><pre><code class="js">export const delChannel = (channelId) =&gt; {
  return new Promise(async (resolve, reject) =&gt; {
    try {
      const { user } = store.state
      if (user.token) {
      // 登录
        await request(`/app/v1_0/user/channels/${channelId}`, &#39;DELETE&#39;)
        // 成功
        resolve()
      } else {
      // 未登录
      // 1. 获取本地的频道  数组
        const localChannels = JSON.parse(window.localStorage.getItem(CHANNEL_KEY))
        // 2. 根据ID获取索引
        const index = localChannels.findIndex(item =&gt; item.id === channelId)
        // 3. 使用splice进行删除
        localChannels.splice(index, 1)
        // 4. 更新本地存储
        window.localStorage.setItem(CHANNEL_KEY, JSON.stringify(localChannels))
        // 5. 调用成功
        resolve()
      }
    } catch (e) {
      reject(e)
    }
  })
}</code></pre>
<h1 id="删除我的频道功能"><a href="#删除我的频道功能" class="headerlink" title="删除我的频道功能"></a>删除我的频道功能</h1><ul>
<li>绑定事件，进行删除</li>
</ul>
<pre><code class="html">&lt;van-icon @click=&quot;delChannel(i,item.id)&quot;&gt;&lt;/van-icon&gt;</code></pre>
<pre><code class="js"> // 删除频道
    async delChannel (index, channelId) {
      try {
        // 1. 调用接口删除频道
        await delChannel(channelId)
        // 2. 提示  &#39;删除成功&#39;
        this.$toast({ type: &#39;success&#39;, message: &#39;删除成功&#39; })
        // 3. 移除频道 （当前组件，父组件）
        // 当父组件传递的数据为简单数据类型的时候，不能修改，此时的修改是赋值，改变引用。
        // 当父组件传递的数据为复杂数据类型的时候，可以修改，在保证引用不被修改的情况，修改数据。
        // 4. 有情况：
        // 4.1 当激活的频道是最后一个频道，删除当前激活的频道， 当前激活的频道往前推一位
        // 4.2 当前你删除的频道是当前激活频道的前面的频道，当前激活的频道往前推一位
        if (index &lt;= this.activeIndex) {
        // 让activeIndex往前推一位
        // 通知父组件修改 activeIndex
          this.$emit(&#39;update:activeIndex&#39;, this.activeIndex - 1)
        }
        this.channels.splice(index, 1)
      } catch (e) {
        this.$toast({ type: &#39;fail&#39;, message: &#39;删除失败&#39; })
      }
    },</code></pre>
<ul>
<li>通知父组件，删除成功，需要判断激活的频道是否有数据，没有需要加载。<ul>
<li>移动到的频道没有数据，需要主动的去加载数据</li>
<li>下面代码 请忽略。</li>
</ul>
</li>
</ul>
<pre><code class="diff">   &lt;edit-channel
      v-model=&quot;showEditChannel&quot;
      :channels=&quot;channels&quot;
+     @on-delete=&quot;changeChannel&quot;
      :activeIndex.sync=&quot;activeIndex&quot;&gt;
    &lt;/edit-channel&gt;</code></pre>
<h1 id="添加我的频道API参数设置"><a href="#添加我的频道API参数设置" class="headerlink" title="添加我的频道API参数设置"></a>添加我的频道API参数设置</h1><ul>
<li>绑定事件，提供（添加频道）数据。</li>
</ul>
<pre><code class="html">&lt;van-icon name=&quot;plus&quot; @click=&quot;addChannel(item)&quot; class=&quot;btn&quot;&gt;&lt;/van-icon&gt;</code></pre>
<ul>
<li>接口需要实现  调用后台接口与本地存储功能<ul>
<li>后台需要排序  [{id:’频道ID’,seq,’排序’}]</li>
<li>本地需要 {id:’频道ID’,name:’频道名称’}</li>
</ul>
</li>
</ul>
<pre><code class="js"> addChannel ({ id, name }) {
      // 后端：对应频道是有排序的，｛频道1，序号 3｝｛频道2，序号 1｝
      // 后端：返回频道数据的时候，并没有返回序号，想往最后追加数据，需要知道最大序号。
      // 采用：是覆盖式修改，在传递频道数据的同时，在前端排好序提交数据给后端
      // 数据：[{id:&#39;频道ID&#39;,seq:1},...]
      const newChannels = this.channels.map((item, i) =&gt; ({
        id: item.id,
        name: item.name,
        seq: i
      }))
      // 不包含推荐
      newChannels.splice(0, 1)
      newChannels.push({ id, name, seq: newChannels.length + 1 })
    },</code></pre>
<h1 id="添加我的频道API"><a href="#添加我的频道API" class="headerlink" title="添加我的频道API"></a>添加我的频道API</h1><pre><code class="js">/**
 * 添加频道
 * @param {Array} orderChannels - 排序好的频道数据 [{id:&#39;频道ID&#39;,seq:1,name:&#39;频道名称&#39;},...]
 */
export const addChannel = (orderChannels) =&gt; {
  // 实现添加频道  登录状态（调用接口）  未登录状态（使用本地存储）
  return new Promise(async (resolve, reject) =&gt; {
    try {
      const { user } = store.state
      if (user.token) {
        // 登录状态（调用接口）
        await request(&#39;/app/v1_0/user/channels&#39;, &#39;put&#39;, {
          // orderChannels 内包含name字段，没关系
          channels: orderChannels
        })
        // 处理成功
        resolve()
      } else {
        // 未登录状态（使用本地存储）
        // 1. 获取本地的频道
        const jsonStr = window.localStorage.getItem(CHANNEL_KEY)
        const localChannels = JSON.parse(jsonStr)
        // 2. 插入添加的频道
        const { id, name } = orderChannels[orderChannels.length - 1]
        localChannels.push({ id, name })
        // 3. 再次的存储在本地
        window.localStorage.setItem(CHANNEL_KEY, JSON.stringify(localChannels))
        // 4. 处理成功
        resolve()
      }
    } catch (e) {
      reject(e)
    }
  })
}</code></pre>
<h1 id="添加我的频道功能"><a href="#添加我的频道功能" class="headerlink" title="添加我的频道功能"></a>添加我的频道功能</h1><pre><code class="js">    // 添加频道
    async addChannel ({ id, name }) {
      // 调用封装好的Api (支持两种方式)
      // 后端数据格式
      // 后端：对应频道是有排序的，｛频道1，序号 3｝｛频道2，序号 1｝
      // 后端：返回频道数据的时候，并没有返回序号，想往最后追加数据，需要知道最大序号。
      // 采用：是覆盖式修改，在传递频道数据的同时，在前端排好序提交数据给后端
      // 注意：后端需要的数据，不包含推荐，是默认频道 永远是第一。
      // 数据：[{id:&#39;频道ID&#39;,seq:1},...]
      // 本地存储数据格式
      // 数据：{id:&#39;频道ID&#39;,name:&#39;频道名称&#39;}
      // 需求：把两个数据合并在一起，在API中才能实现两个逻辑。
      // 数据：[{id:&#39;频道ID&#39;,seq:1,name:&#39;频道名称&#39;},....最后一个本地需要的对象]
      const newChannels = this.channels.map((item, i) =&gt; ({
        id: item.id,
        name: item.name,
        seq: i
      }))
      newChannels.splice(0, 1)
      newChannels.push({ id, name, seq: newChannels.length + 1 })
      try {
        // 调用接口实现  添加频道
        await addChannel(newChannels)
        // 添加成功
        // 1. 提示  添加成功
        this.$toast({ type: &#39;success&#39;, message: &#39;添加成功&#39; })
        // 2. 更新组件界面，往channels中加入一个频道即可
        // 2.1 注意：频道编辑  文章列表 都有频道。 但是 复杂数据类型，没有修改引用地址，允许修改
        this.channels.push({
          id,
          name,
          // 是否正在上拉加载中
          upLoading: false,
          // 是否正在下拉刷新中
          downLoading: false,
          // 是否加载了所有的数据
          finished: false,
          // 文章列表
          articles: [],
          // 获取数据的时间戳
          timestamp: Date.now(),
          // 阅读位置
          scrollTop: 0
        })
      } catch (e) {
        this.$toast({ type: &#39;fail&#39;, message: &#39;添加失败&#39; })
      }
    },</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue移动端</title>
    <url>/2020/04/14/vue/vue%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="使用vant"><a href="#使用vant" class="headerlink" title="使用vant"></a>使用vant</h1><pre><code>npm i vant -S

import Vue from &#39;vue&#39;;
import Vant from &#39;vant&#39;;
import &#39;vant/lib/index.css&#39;;

Vue.use(Vant);</code></pre><h1 id="移动端rem适配"><a href="#移动端rem适配" class="headerlink" title="移动端rem适配"></a>移动端rem适配</h1><pre><code># 后处理器 开发阶段使用
npm i postcss-pxtorem -D
# 修改rem基准值的js插件   需要在打包后需要使用
npm i amfe-flexible -S</code></pre><p> postcss 配置（postcss.config.js）</p>
<pre><code>module.exports = {
  plugins: {
    &#39;autoprefixer&#39;: {},
     &#39;postcss-pxtorem&#39;: {
      rootValue: 37.5,
      propList: [&#39;*&#39;]
    }
  }
}</code></pre><p>入口文件main.js导入 amfe-flexible </p>
<pre><code>import &#39;amfe-flexible&#39;</code></pre><ul>
<li>rootValue 是转换px的基准值，参考设备iPhone6，设备宽度375px。</li>
<li>flexible 在iPhone6设备设置的  html—&gt;font-size 也为37.5px 。</li>
</ul>
<h1 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h1><pre><code>&lt;van-cell-group&gt;
    &lt;van-field @blur=&quot;checkMobile&quot; 
               :error-message=&quot;errMsg.mobile&quot; 
               v-model.trim=&quot;loginForm.mobile&quot;  
               label=&quot;手机号&quot; placeholder=&quot;请输入手机号&quot; /&gt;
    &lt;van-field @blur=&quot;checkCode&quot; 
               :error-message=&quot;errMsg.code&quot; 
               v-model.trim=&quot;loginForm.code&quot;  
               label=&quot;验证码&quot; placeholder=&quot;请输入验证码&quot;&gt;
        &lt;van-button class=&quot;p10&quot; slot=&quot;button&quot; size=&quot;mini&quot; type=&quot;primary&quot;&gt;
            发送验证码
        &lt;/van-button&gt;
    &lt;/van-field&gt;
&lt;/van-cell-group&gt;
&lt;div class=&quot;btn_box&quot;&gt;
    &lt;van-button type=&quot;info&quot; @click=&quot;login&quot; block round&gt;登 录&lt;/van-button&gt;
&lt;/div&gt;</code></pre><pre><code>// error-message    底部错误提示文案，为空时不展示
// 监听失去焦点事件  获取当前表单元素的数据 进行校验
// 点击登录的时候，全部表单元素校验一次
export default {
  name: &#39;user-login&#39;,
  data () {
    return {
      // 错误提示
      errMsg: {
        mobile: &#39;&#39;,
        code: &#39;&#39;
      },
      // 表单数据
      loginForm: {
        mobile: &#39;&#39;,
        code: &#39;&#39;
      }
    }
  },
  methods: {
    checkMobile () {
      // 校验手机号
      // 1. 非空
      if (!this.loginForm.mobile) {
        this.errMsg.mobile = &#39;请输入手机号&#39;
        return false
      }
      // 2. 格式
      if (!/^1[3-9]\d{9}$/.test(this.loginForm.mobile)) {
        this.errMsg.mobile = &#39;手机号格式错误&#39;
        return false
      }
      this.errMsg.mobile = &#39;&#39;
    },
    checkCode () {
      // 校验验证码
      // 1. 非空
      if (!this.loginForm.code) {
        this.errMsg.code = &#39;请输入验证码&#39;
        return false
      }
      // 2. 格式
      if (!/^\d{6}$/.test(this.loginForm.code)) {
        this.errMsg.code = &#39;验证码为6个数字&#39;
        return false
      }
      this.errMsg.code = &#39;&#39;
    },
    ...mapMutations([&#39;setUser&#39;]),
   async login () {
      // 整个表单进行校验
      this.checkMobile()
      this.checkCode()
      // 判断校验结果
      if (this.errMsg.mobile || this.errMsg.code) {
        // 校验失败
        return false
      }
      try {
        // 校验成功  （进行登录）
        const data = await login(this.loginForm)
        // 登录成功
        // 1. 提示
        this.$toast({ type: &#39;success&#39;, message: &#39;登录成功&#39; })
        // 2. 保存token
        this.setUser(data)
        // 3. 根据地址栏是否有回跳的地址  如果有 回调即可  如果没  个人中心 /user
        const url = this.$route.query.redirect || &#39;/user&#39;
        this.$router.push(url)
      } catch (e) {
        // 4. 错误提示
        this.$toast({ type: &#39;fail&#39;, message: &#39;登录失败&#39; })
      }
    }
  }</code></pre><h1 id="时间格式处理"><a href="#时间格式处理" class="headerlink" title="时间格式处理"></a>时间格式处理</h1><pre><code>import dayjs from &#39;dayjs&#39;
import relativeTime from &#39;dayjs/plugin/relativeTime&#39;
import &#39;dayjs/locale/zh-cn&#39;
dayjs.extend(relativeTime)</code></pre><p>utils/plugin.js</p>
<pre><code>// 工具函数、过滤器、自定义指令
import dayjs from &#39;dayjs&#39;
import relativeTime from &#39;dayjs/plugin/relativeTime&#39;
import &#39;dayjs/locale/zh-cn&#39;
dayjs.extend(relativeTime)

const $sleep = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    window.setTimeout(() =&gt; {
      resolve()
    }, 1000)
  })
}

const relTime = (strDate) =&gt; {
  return dayjs().locale(&#39;zh-cn&#39;).from(strDate)
}
// 过滤器函数
export default {
  install (Vue) {
    Vue.prototype.$sleep = $sleep
    Vue.filter(&#39;relTime&#39;, relTime)
  }
}
</code></pre><p>使用</p>
<pre><code>&lt;span&gt;{{article.pubdate|relTime}}&lt;/span&gt;</code></pre><h1 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h1><p><strong><keep-alive></keep-alive></strong>缓存组件实例，组件切回来还在原位置</p>
<ul>
<li>激活组件的时候，是不会触发 created 钩子。</li>
<li>激活组件钩子 <a href="https://cn.vuejs.org/v2/api/#activated" target="_blank" rel="noopener">activated</a></li>
<li>失活组件钩子<a href="https://cn.vuejs.org/v2/api/#deactivated" target="_blank" rel="noopener">deactivated</a></li>
</ul>
<p>路由中</p>
<pre><code>{ path: &#39;/article/:id&#39;, name: &#39;article&#39;, component: Article, meta: { keepAlive: true } }</code></pre><p>src/app.vue</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;keep-alive&gt;
    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;
  &lt;/keep-alive&gt;
  &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;
&lt;/div&gt;</code></pre><h1 id="阅读记忆"><a href="#阅读记忆" class="headerlink" title="阅读记忆"></a>阅读记忆</h1><p><van-tab>默认是懒加载，渲染内容的时候，延时渲染内容。关闭懒加载，lazy-render  属性的值  false</van-tab></p>
<ul>
<li><p>切换tab组件的时候，主动的去加载文章列表数据。</p>
<ul>
<li>如果之前没有加载过数据，开启上拉加载效果，调用加载函数。</li>
<li>如果有数据，不需要做任何事情。</li>
</ul>
</li>
<li><p>绑定滚动事件，记录阅读位置，使用scrollTop</p>
</li>
<li><p>激活组件的时候，操作当前列表，滚动到阅读位置</p>
</li>
<li><p>当激活组件的时候，切换到其他频道：</p>
<ul>
<li><p>默认滚动到了顶部，tab组件干的。</p>
</li>
<li><p>使用 nextTick 中  根据记录的位置去设置滚动位置</p>
</li>
</ul>
</li>
</ul>
<pre><code>&lt;van-tabs :lazy-render=&quot;false&quot;&gt;&lt;/van-tabs&gt;</code></pre><pre><code>&lt;div  @scroll=&quot;remember($event)&quot;&gt;&lt;/div&gt;

// scrollTop: 0  默认
remember (e) {
    // 在当前频道下记录  目前滚动的位置
    this.activeChannel.scrollTop = e.target.scrollTop
},</code></pre><p>激活组件时跳转到阅读位置</p>
<pre><code>activated () {
    // ref=&quot;scroll-wrapper&quot;  遍历后有很多个容器拥有属性 [dom0,dom1,dom2,...]
    const domArr = this.$refs[&#39;scroll-wrapper&#39;]
    if (domArr) {
      const scrollWrapper = domArr[this.activeIndex]
      const scrollTop = this.activeChannel.scrollTop
      // 设置滚动的容器 的scrollTop属性为阅读位置  即可
      scrollWrapper.scrollTop = scrollTop
    }
  },</code></pre><p>切换组件</p>
<pre><code>changeChannel () {
      if (!this.activeChannel.articles.length) {
        // 开启当前频道的上拉加载效果
        this.activeChannel.upLoading = true
        // 主动加载当前频道的数据
        this.onLoad()
      } else {
        // window.setTimeout(() =&gt; {
        //   const domArr = this.$refs[&#39;scroll-wrapper&#39;][this.activeIndex]
        //   domArr.scrollTop = this.activeChannel.scrollTop
        // }, 0)
        // vue 提供了上述类似的功能  $nextTick()   下一帧后执行（延时一些时间）
        // $nextTick   使用场景：改变数据，驱动视图更新，马上去操作dom（获取不到dom）,在$nextTick中操作dom
        this.$nextTick(() =&gt; {
          const domArr = this.$refs[&#39;scroll-wrapper&#39;][this.activeIndex]
          domArr.scrollTop = this.activeChannel.scrollTop
        })
      }
    },</code></pre><h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><p><strong>当图片进入可视区域内再进行加载</strong></p>
<h2 id="1-vant内置的插件"><a href="#1-vant内置的插件" class="headerlink" title="1 vant内置的插件"></a>1 vant内置的插件</h2><pre><code>import Vant, { Lazyload } from &#39;vant&#39;
Vue.use(Lazyload)</code></pre><pre><code>&lt;van-image lazy-load&gt;&lt;/van-image&gt;</code></pre><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><pre><code>npm i vue-lazyload

import VueLazyload from &#39;vue-lazyload&#39;
Vue.use(VueLazyload)</code></pre><pre><code>&lt;van-image lazy-load&gt;&lt;/van-image&gt;</code></pre><p>需要依赖 v-lazy 指令</p>
<pre><code>&lt;img v-lazy=&quot;img.src&quot; &gt;</code></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组的方法</title>
    <url>/2020/04/14/js/js%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="js数组方法总结"><a href="#js数组方法总结" class="headerlink" title="js数组方法总结"></a>js数组方法总结</h1><h2 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h2><pre><code>this.questionDetails = this.questionDetails.filter(item =&gt; {
   item.TimeSpan = formatDate(new Date(item.TimeSpan), &#39;yyyy-MM-dd hh:mm:ss&#39;)
        return item
})</code></pre><h2 id="findIndex-splice"><a href="#findIndex-splice" class="headerlink" title="findIndex+splice"></a>findIndex+splice</h2><pre><code>// findIndex 找到下标
const index = this.historyList.findIndex(item =&gt; item === text)
// 删除下标为index的数据
this.historyList.splice(index, 1)
window.localStorage.setItem(KEY, JSON.stringify(this.historyList))</code></pre><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><pre><code>const data = await suggestion(this.q)
this.suggestList = data.options.map(
    item =&gt; item.toLowerCase().replace(this.q, `&lt;span&gt;${this.q}&lt;/span&gt;`)
)</code></pre><p><strong>重组数组, 用大括号包裹可不用return</strong></p>
<pre><code class="js">this.channels = data.channels.map(item =&gt; ({
    id: item.id,
    name: item.name,
    upLoading: false,
    downLoading: false,
    finished: false,
    articles: [],
    timestamp: Date.now(),
    scrollTop: 0
}))</code></pre>
<p><strong>不改变原数组</strong></p>
<pre><code class="js">var a = [1,2,2,2,3,4,5]
var b = []
b = a.map(item =&gt; {
    return item + 3
})
console.log(a)  // [1,2,2,2,3,4,5]
console.log(b)  // [4,5,5,5,6,7,8]</code></pre>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><pre><code>// ES6的 Set  是构造函数  const set = new Set(数组)  set是一个集合，不能拥护重复数据
// 去重
const set = new Set(this.historyList)
set.add(text)
this.historyList = Array.from(set)</code></pre><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><strong>找到第一个满足条件的元素</strong></p>
<pre><code class="js">var a = [1,2,3,4,5]
var a = [1,2,3,4,5]
var b = a.find(item =&gt; {
    return item &gt; 3
})
console.log(b)   // 4</code></pre>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><strong>遍历数组，不改变原数组</strong></p>
<pre><code class="js">var a = [1,2,2,2,3,4,5]
a.forEach(item =&gt; {
    item = item + 3
    console.log(item)   // 4,5,5,5,6,7,8
})
console.log(a)  //[1,2,2,2,3,4,5]

var a = [1,2,2,2,3,4,5]
var b = []
a.forEach(item =&gt; {
    item = item + 3
    b.push(item)
})
console.log(b)   // b = [4,5,5,5,6,7,8]</code></pre>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p><strong>查找第一个满足条件的索引,找不到返回-1</strong></p>
<pre><code class="js">var a = [1,2,2,2,3,4,5]
var b = a.indexOf(2)
console.log(b)   // 1

var a = [1,2,2,2,3,4,5]
var b = a.indexOf(10)
console.log(b)   // -1</code></pre>
<h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h2><p><strong>从后往前找，找到第一个满足条件的索引,找不到返回-1**</strong></p>
<pre><code class="js">var a = [1,2,2,2,3,4,5]
var b = a.lastIndexOf(2)
console.log(b)  // 3

var a = [1,2,2,2,3,4,5]
var b = a.lastIndexOf(10)
console.log(b)   // -1</code></pre>
<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p><strong>数组中有一个满足条件就返回true</strong></p>
<pre><code class="js">var a = [1,2,2,2,3,4,5]
var b = a.some(item =&gt; {
    return item &gt; 3
})
console.log(b)  // true</code></pre>
<h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p><strong>数组中全部满足条件返回true</strong></p>
<pre><code class="js">var a = [1,2,2,2,3,4,5]
var b = a.every(item =&gt; {
    return item &gt; 3
})
console.log(b)   // false</code></pre>
<h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p><strong>是否含有某元素</strong></p>
<pre><code class="js">var a = [1,2,2,2,3,4,5]
var b = a.includes(2)
console.log(b)   // true</code></pre>
<pre><code class="js">var a = [1,2,2,2,3,4,5]
var b = a.includes(10)
console.log(b)   // false</code></pre>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索记录</title>
    <url>/2020/04/14/vue/%E6%90%9C%E7%B4%A2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="搜素记录"><a href="#搜素记录" class="headerlink" title="搜素记录"></a>搜素记录</h1><pre><code>&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;van-nav-bar title=&quot;搜索中心&quot; left-arrow @click-left=&quot;$router.back()&quot; /&gt;
    &lt;!-- 去掉输入框内首尾空格 --&gt;
    &lt;van-search v-model.trim=&quot;q&quot; placeholder=&quot;请输入搜索关键词&quot; shape=&quot;round&quot; @search=&quot;onSearch&quot;/&gt;
    &lt;van-cell-group class=&quot;suggest-box&quot; v-if=&quot;q&quot;&gt;
      &lt;van-cell @click=&quot;onSearch(sug.replace(`&lt;span&gt;${q}&lt;/span&gt;`, q))&quot; icon=&quot;search&quot; v-for=&quot;sug in suggestList&quot; :key=&quot;sug&quot;&gt;&lt;p v-html=&quot;sug&quot;&gt;&lt;/p&gt;&lt;/van-cell&gt;
    &lt;/van-cell-group&gt;
    &lt;div class=&quot;history-box&quot; v-else-if=&quot;historyList.length&quot;&gt;
      &lt;div class=&quot;head&quot;&gt;
        &lt;span&gt;历史记录&lt;/span&gt;
        &lt;van-icon name=&quot;delete&quot; @click=&quot;clearSuggest&quot;&gt;&lt;/van-icon&gt;
      &lt;/div&gt;
      &lt;van-cell-group&gt;
        &lt;van-cell v-for=&quot;item in historyList&quot; :key=&quot;item&quot;&gt;
          &lt;a class=&quot;word_btn&quot; @click=&quot;toSearch(item)&quot;&gt;{{item}}&lt;/a&gt;
          &lt;van-icon @click=&quot;delSuggest(item)&quot; class=&quot;close_btn&quot; slot=&quot;right-icon&quot; name=&quot;cross&quot;/&gt;
        &lt;/van-cell&gt;
      &lt;/van-cell-group&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { suggestion } from &#39;@/api/articles&#39;
const KEY = &#39;searchKeywors&#39;
export default {
  data () {
    return {
      q: &#39;&#39;,
      timer: null,
      historyList: [],
      suggestList: []
    }
  },
  created () {
    this.historyList = JSON.parse(window.localStorage.getItem(KEY) || &#39;[]&#39;)
  },
  watch: {
    q () {
       // 函数防抖
       // 函数防抖：在规定时间内，再次执行，清除上一次执行，重新执行。
        // 运用场景：搜索提示，在开销较大操作需要频繁执行的时候（页面尺寸改变，滚动条滚动）
        // 函数节流：在规定时间内，再次执行，必须等上一次执行完毕，才能执行。
      // 运用场景: 轮播图
      window.clearTimeout(this.timer)
      this.timer = window.setTimeout(async () =&gt; {
        if (!this.q) {
          this.suggestList = []
          return false
        }
        const data = await suggestion(this.q)
        this.suggestList = data.options.map(
          item =&gt; item.toLowerCase().replace(this.q, `&lt;span&gt;${this.q}&lt;/span&gt;`)
        )
      }, 200)
    }
  },
  methods: {
    toSearch (text) {
      this.$router.push({ path: &#39;/search/result&#39;, query: { q: text } })
    },
    clearSuggest () {
      this.historyList = []
      window.localStorage.setItem(KEY, JSON.stringify(this.historyList))
    },
    delSuggest (text) {
      // findIndex 找到下标
      const index = this.historyList.findIndex(item =&gt; item === text)
      // 删除下标为index的数据
      this.historyList.splice(index, 1)
      window.localStorage.setItem(KEY, JSON.stringify(this.historyList))
    },
    onSearch (text) {
      if (!this.q) return false
      const set = new Set(this.historyList)
      set.add(text)
      this.historyList = Array.from(set)
      window.localStorage.setItem(KEY, JSON.stringify(this.historyList))
      this.$router.push({ path: &#39;/search/result&#39;, query: { q: text } })
    }
  }
}
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
.history-box {
  padding: 0 20px;
  .head{
    line-height: 36px;
    color: #999;
    .van-icon{
      font-size: 16px;
      float: right;
      margin-top: 10px;;
    }
  }
  .van-cell{
    padding: 10px 0;
  }
  .word_btn{
    color:#3296fa;
  }
  .close_btn{
    margin-top:5px;
    color: #999;
  }
}
.suggest-box{
  /deep/ .van-cell{
    padding: 10px 20px;
    color: #999;
    p{
      span{
        color: red;
      }
    }
  }
}
&lt;/style&gt;
</code></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2020/04/14/websocket/websocket/</url>
    <content><![CDATA[<h1 id="使用websocket"><a href="#使用websocket" class="headerlink" title="使用websocket"></a>使用websocket</h1><p>​    <strong>通信模型</strong></p>
<ul>
<li><p>拨号：建立连接</p>
</li>
<li><p>通话：双向通信</p>
</li>
<li><p>结束通话：关闭连接</p>
<pre><code>// 原生
// 创建连接
var ws = new WebSoket(&#39;wss://echo.websocket.org&#39;)
// 连接成功
ws.onopen = function (evt) {
    console.log(&#39;Connection open...&#39;)
    // 发消息
    ws.send(&#39;Hello&#39;)
}
// 接消息
ws.onmessage = function(evt) {
    console.log(&#39;received Message&#39; + evt.data)
    // 关闭连接
    wx.close()
}
wx.onclose = function (evt) {
    console.log(&#39;connection closed&#39;)
}</code></pre></li>
</ul>
<h1 id="使用socket-io"><a href="#使用socket-io" class="headerlink" title="使用socket.io"></a>使用socket.io</h1><p>​    <a href="https://socket.io/" target="_blank" rel="noopener">https://socket.io/</a></p>
<p>​    <a href="https://github.com/socketio/socket.io" target="_blank" rel="noopener">https://github.com/socketio/socket.io</a></p>
<p>服务端</p>
<pre><code>var app = require(&#39;express&#39;)()
var http = require(&#39;http&#39;).createServer(app)
var io = require(&#39;socket.io&#39;)(http)

app.get(&#39;/&#39;, function(req, res) {
    res.sendFile(__dirname + &#39;/index.html&#39;)
})

io.on(&#39;connection&#39;, function(socket) {
    socket.on(&#39;disconnect&#39;, function() {
        console.log(&#39;user disconnect&#39;)
    })

    socket.on(&#39;chat message&#39;, function(msg) {
        io.emit(&#39;chat message&#39;, msg)
    })
})

http.listen(3000, &#39;0.0.0.0&#39;, function(){
    console.log(&#39;listening on *: 3000&#39;)
})</code></pre><p>客服端代码</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Socket.IO chat&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; &gt;                  
    &lt;style&gt;
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial; }
      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
      #messages { list-style-type: none; margin: 0; padding: 0; }
      #messages li { padding: 5px 10px; }
      #messages li:nth-child(odd) { background: #eee; }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 消息列表 --&gt;
    &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt;

    &lt;!-- 发送消息的表单 --&gt;
    &lt;form action=&quot;&quot;&gt;
      &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt;
    &lt;/form&gt;

    &lt;!-- SocketIO 提供了一个客户端实现：socket.io.js --&gt;
    &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://code.jquery.com/jquery-1.11.1.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      // 建立连接，得到 socket 通信对象
      var socket = io()

      socket.on(&#39;connect&#39;, () =&gt; {
        console.log(&#39;成功建立连接&#39;)
      })

      $(&#39;form&#39;).submit(function(e){
        e.preventDefault();
        socket.emit(&#39;chat message&#39;, $(&#39;#m&#39;).val());
        $(&#39;#m&#39;).val(&#39;&#39;);
        return false;
      });

      socket.on(&#39;chat message&#39;, function(msg){
        $(&#39;#messages&#39;).append($(&#39;&lt;li&gt;&#39;).text(msg));
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><h1 id="实际应用-vue"><a href="#实际应用-vue" class="headerlink" title="实际应用(vue)"></a>实际应用(vue)</h1><pre><code>npm i socket.io-client</code></pre><pre><code>&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;van-nav-bar fixed left-arrow @click-left=&quot;$router.back()&quot; title=&quot;小智同学&quot;&gt;&lt;/van-nav-bar&gt;
    &lt;div class=&quot;chat-list&quot; ref=&quot;list&quot;&gt;
      &lt;div class=&quot;chat-item&quot; :class=&quot;{left: item.name===&#39;xz&#39;, right: item.name===&#39;zj&#39;}&quot; v-for=&quot;(item,i) in list&quot; :key=&quot;i&quot;&gt;
        &lt;van-image v-if=&quot;item.name===&#39;xz&#39;&quot; fit=&quot;cover&quot; round :src=&quot;xzAvatar&quot; /&gt;
        &lt;div class=&quot;chat-pao&quot;&gt;{{item.msg}}&lt;/div&gt;
        &lt;van-image  v-if=&quot;item.name===&#39;zj&#39;&quot; fit=&quot;cover&quot; round :src=&quot;zjAvatar&quot; /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;reply-container van-hairline--top&quot;&gt;
      &lt;van-field v-model=&quot;value&quot; placeholder=&quot;说点什么...&quot;&gt;
        &lt;van-loading v-if=&quot;commentLoading&quot; slot=&quot;button&quot; type=&quot;spinner&quot; size=&quot;16px&quot;&gt;&lt;/van-loading&gt;
        &lt;span v-else @click=&quot;send()&quot; slot=&quot;button&quot; style=&quot;font-size:12px;color:#999&quot;&gt;提交&lt;/span&gt;
      &lt;/van-field&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import io from &#39;socket.io-client&#39;
import xzAvatar from &#39;../../assets/images/7.jpg&#39;
export default {
  data () {
    return {
      value: &#39;&#39;,
      commentLoading: false,
      xzAvatar,
      zjAvatar: this.$route.query.photo,
      list: []
    }
  },
  created () {
    this.socket = io(&#39;http://ttapi.research.cn&#39;)
    this.socket.on(&#39;connect&#39;, () =&gt; {
      // 默认发消息
      this.list.push({ name: &#39;xz&#39;, msg: &#39;您有什么问题呢？&#39; })
    })
    // 收消息
    this.socket.on(&#39;message&#39;, data =&gt; {
      // 回消息
      this.list.push({ name: &#39;xz&#39;, msg: data.msg })
      this.scrollBottom()
    })
  },
  beforeDestroy () { 
    this.socket.close()
  },
  methods: {
    send () {
      // 和后端约定好消息的名字（message)
      if (!this.value) return false
      // 发消息
      this.socket.emit(&#39;message&#39;, { msg: this.value, timestamp: Date.now() })
      this.list.push({ name: &#39;zj&#39;, msg: this.value })
      this.value = &#39;&#39;
      this.scrollBottom()
    },
    // 每发一条消息都要滚动到最底部
    scrollBottom () {
      this.$nextTick(() =&gt; {
        this.$refs.list.scrollTop = this.$refs.list.scrollHeight
      })
    }
  }
}
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
.container {
  height: 100%;
  width: 100%;
  position: absolute;
  left: 0;
  top: 0;
  box-sizing: border-box;
  background:#fafafa;
  padding: 46px 0 50px 0;
  .chat-list {
    height: 100%;
    overflow-y: scroll;
    .chat-item{
      padding: 10px;
      .van-image{
        vertical-align: top;
        width: 40px;
        height: 40px;
      }
      .chat-pao{
        vertical-align: top;
        display: inline-block;
        min-width: 40px;
        max-width: 70%;
        min-height: 40px;
        line-height: 38px;
        border: 0.5px solid #c2d9ea;
        border-radius: 4px;
        position: relative;
        padding: 0 10px;
        background-color: #e0effb;
        word-break: break-all;
        font-size: 14px;
        color: #333;
        &amp;::before{
          content: &quot;&quot;;
          width: 10px;
          height: 10px;
          position: absolute;
          top: 12px;
          border-top:0.5px solid #c2d9ea;
          border-right:0.5px solid #c2d9ea;
          background: #e0effb;
        }
      }
    }
  }
}
.chat-item.right{
  text-align: right;
  .chat-pao{
    margin-left: 0;
    margin-right: 15px;
    &amp;::before{
      right: -6px;
      transform: rotate(45deg);
    }
  }
}
.chat-item.left{
  text-align: left;
  .chat-pao{
    margin-left: 15px;
    margin-right: 0;
    &amp;::before{
      left: -5px;
      transform: rotate(-135deg);
    }
  }
}
.reply-container {
  position: fixed;
  left: 0;
  bottom: 0;
  height: 44px;
  width: 100%;
  background: #f5f5f5;
  z-index: 9999;
}
&lt;/style&gt;
</code></pre>]]></content>
      <categories>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>vue基础知识</title>
    <url>/2020/04/12/vue/vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="created和mounted"><a href="#created和mounted" class="headerlink" title="created和mounted"></a>created和mounted</h1><p><strong>created</strong>: 用于首屏页面数据的初始化操作</p>
<p><strong>mounted</strong>: 页面以及渲染完毕，可以操作dom</p>
<h1 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h1><p>​    <strong>计算属性可以进行复杂的逻辑运算，使用时当成变量使用，计算属性本身有缓存，在关联的data没有变化的情况下，多次使用节省资源，methods方法没有缓存，每次使用都要重新加载。计算属性需要通过return关键字返回</strong></p>
<p><strong>computed只做值的拼接，最好不要修改，因为可能导致无限循环</strong></p>
<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p>​    <strong>watch侦听器，监听元素的变化，做一些操作</strong></p>
<pre><code class="js,html">&lt;p&gt;FullName: {{fullName}}&lt;/p&gt;

// lastName: &#39;JACK&#39;, firstName: &#39;AMY&#39;, fullName: &#39;&#39;
// watch最初绑定时是不会执行的。下次变化时才会执行(不适合显示数据)
// 要立马执行可绑定handler(), immediate设置为true
watch: {
    firstName (newName, oldName) {
        this.fullName = newName + &#39;&#39; + this.lastName
        console.log(newName, oldName)
    }
}</code></pre>
<pre><code class="js">data () {
    return {
        obj: {
            a: &#39;123&#39;
        }
    }
}
// 对象中有很多个属性，handle默认只监听obj属性的引用的变化（只有给obj赋值时才会触发),  // 改变内部的属性不会触发
// deep用来深入观察，把obj里面的所有属性遍历一遍，一层一层所有都加上监听事件（内存消耗大）
watch: {
    obj: {
        handle () {
            console.log(&#39;obj.a changed&#39;)
        },
        immediate: true,
        deep: true
    }
}

// 可改为
watch: {
    &#39;obj.a&#39;: {
        handle () {
            console.log(&#39;obj.a changed&#39;)
        },
        immediate: true
    }
}</code></pre>
<h1 id="为什么组件的data必须是一个function"><a href="#为什么组件的data必须是一个function" class="headerlink" title="为什么组件的data必须是一个function"></a>为什么组件的data必须是一个function</h1><p>​    <strong>data可被使用多次，function的特点是每次使用时都会亲自执行，并给当前对象分配一个独立的数据对象，多个组件的data是独立的，没有影响</strong></p>
<p>​    <strong>若直接通过{}给data复制，多次使用组件会造成data共享，就是一份数据，一个组件修改data后所有的组件都受影响，一并被修改了</strong></p>
<h1 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set()"></a>Vue.set()</h1><p>​    <strong>对于已经创建的实例，vue不允许动态增加根级别的响应式属性，但是可以使用Vue.set(obj, propertyName, value)方法向嵌套对象添加响应式属性</strong></p>
<p>​    <strong>实例化（new vue)时，把data中的数据设置为响应式数据，set方法不能给vue实例或$data的根位置添加响应式数据，可以给data中的成员添加属性</strong></p>
<h1 id="vue不直接操作dom"><a href="#vue不直接操作dom" class="headerlink" title="vue不直接操作dom"></a>vue不直接操作dom</h1><p>​    <strong>网页加载后，会在浏览器内存帮我们维护一个dom树，修改数据，浏览器会监视DOM树，dom树内容发生变化，浏览器会渲染页面，重新渲染会导致重排和重绘</strong></p>
<p>​    <strong>vue在更新数据时不会直接更新dom树，更新虚拟dom，虚拟dom相当于一个中间层，能够跨平台移植</strong></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>mvvm</title>
    <url>/2020/04/12/vue/mvvm/</url>
    <content><![CDATA[<h1 id="MVVM-数据驱动视图"><a href="#MVVM-数据驱动视图" class="headerlink" title="MVVM(数据驱动视图)"></a>MVVM(数据驱动视图)</h1><p>M:model    (普通javascript对象，普通数据)</p>
<p>V:view    (视图,HTML、DOM模板)</p>
<p>VM:    负责数据和视图的更新，是model和view通信的一个桥梁</p>
<h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h1><p><strong>Object.defineProperty(obj, prop, description)</strong></p>
<p>obj: 要在其上定义属性的对象</p>
<p>prop: 要定义或修改的属性的名称</p>
<p>description: 被定义或被修改的属性描述符</p>
<p><strong>属性描述符分为数据描述符和存取描述符</strong>：</p>
<p>​    数据描述符：是一个具有值的属性（可写/只读）</p>
<p>​        可被修改：configurable: true</p>
<p>​        可枚举(遍历)：enumerable: true</p>
<p>​        可写：writable: true</p>
<p>​    存取描述符：</p>
<p>​        get:  给属性提供getter的方法，没有getter为undefined,方法执行时没有参数传入，但会传入this对象</p>
<p>​        set:  给属性提供setter的方法，没有setter为undefined,属性值修改时触发该方法，接收唯一参数，该属</p>
<p>​            性新的参数值</p>
<h1 id="如何实现双向MVVM绑定"><a href="#如何实现双向MVVM绑定" class="headerlink" title="如何实现双向MVVM绑定"></a>如何实现双向MVVM绑定</h1><p><strong>1、实现双向绑定的方法</strong></p>
<p>​    &lt;1&gt;    发布-订阅者模式：一般通过sub、pub方式实现数据和视图的监听绑定，通常Vue.set(‘property’, value)</p>
<p>​    &lt;2&gt;    脏值检查：如angular.js</p>
<p>​    &lt;3&gt;    数据劫持：vue.js采用数据劫持结合发布者-订阅者的模式，通过object.defineproperty()来劫持各个属性的getter、setter在数据变动时发布消息给订阅者，触发相应的监听回调</p>
<p><strong>2、实现mvvm模式的方法</strong></p>
<p>​    &lt;1&gt;    实现一个数据监听器Observer,能够对所有数据对象的属性进行监听，如有变动可拿到最新值通知给订阅者</p>
<p>​    &lt;2&gt;    实现一个指令解析器Compiler，对每个元素的节点进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p>
<p>​    &lt;3&gt;    实现一个Watcher，连接Observer和Compiler，能够订阅并收到每个属性变动的通知，执行指令绑定的相应的回调函数，从而更新视图</p>
<p>​    &lt;4&gt;    MVVM入口函数，整合以上三者</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/04/12/git/git/</url>
    <content><![CDATA[<h1 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h1><p><strong>克隆</strong>：git clone 远程仓库地址</p>
<p><strong>初始化</strong>：git init</p>
<p><strong>第一次提交</strong>：git remote add origin 远程仓库地址</p>
<p>​            git push -u origin master</p>
<p><strong>添加到暂存区</strong>： git add .</p>
<p><strong>将暂存区的文件提交到仓库</strong>： git commit -m ‘描述’</p>
<p><strong>将本地仓库的文件提交到远程仓库</strong>：git push</p>
<p><strong>从远程仓库下载文件</strong>： git pull</p>
<p><strong>创建分支</strong>： git branch dev(分支名)</p>
<p><strong>查看分支</strong>： git branch</p>
<p><strong>切换分支</strong>： git checkout dev</p>
<p><strong>创建并切换分支</strong>： git checkout -b dev</p>
<p><strong>删除分支</strong>： git branch -d dev</p>
<p><strong>查看日志</strong>： git log</p>
<p><strong>查看日志（一行显示）</strong>： git log –oneline</p>
<p><strong>查看文件状态</strong>： git status</p>
<p><strong>重置暂存区</strong>： git reset 文件名</p>
<p><strong>重置暂存区、工作区</strong>： git reset –hard</p>
<p><strong>合并分支</strong>: git merge 分支名     出错，左下角   :q!   强制退出</p>
<p><strong>将add的文件从暂存区删除</strong>： git rm -cashed 文件名</p>
<p><strong>删除文件夹所有文件</strong>： git rm r -cashed 文件名</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax</title>
    <url>/2020/04/12/ajax/ajax/</url>
    <content><![CDATA[<h1 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h1><p><strong>get</strong>:</p>
<p>获取内容</p>
<p>浏览器对长度有限制（2kb）</p>
<p>可以在url上携带少量数据</p>
<p>不要携带隐私数据</p>
<p>参数写在url上</p>
<p><strong>post</strong>:</p>
<p>提交数据</p>
<p>登录时携带隐私数据</p>
<p>可以发送大量数据</p>
<p>可以发送文件</p>
<p>参数放在请求体中</p>
<h1 id="ajax发送请求"><a href="#ajax发送请求" class="headerlink" title="ajax发送请求"></a>ajax发送请求</h1><p><strong>1、创建XMLHTTPRequest对象</strong></p>
<p><strong>2、调用xhr的open方法，设置请求方式和请求的url</strong></p>
<p><strong>3、调用xhr对象的send方法，发送请求</strong></p>
<p><strong>4、当请求响应整个过程结束，才接受服务器返回的数据</strong></p>
<p><strong>get请求</strong></p>
<pre><code>var xhr = new XMLHttpRequest()
xhr.open(&#39;get&#39;, &#39;/time&#39;)
xhr.send()
xhr.onload = function() {
    console.log(xhr.response)
}</code></pre><p><strong>post请求</strong></p>
<pre><code>var xhr = new XMLHttpRequest()
xhr.open(&#39;post&#39;, &#39;/query-post&#39;)
xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)
xhr.send(&#39;name=zxt&amp;age=18&#39;)
xhr.onload = function() {
    console.log(this.responseText)
}</code></pre><h1 id="readyState（ajax请求过程中的几个状态）"><a href="#readyState（ajax请求过程中的几个状态）" class="headerlink" title="readyState（ajax请求过程中的几个状态）"></a>readyState（ajax请求过程中的几个状态）</h1><p><strong>服务器如果返回的数据非常大，会分块返回，当返回的数据发生变化时会触发onreadystatechange事件</strong></p>
<p>readystate有5个状态</p>
<p>0    UNSEND    代理xhr被创建，但尚未调用open方法</p>
<p>1    OPENED        open()方法以及被调用，建立了连接</p>
<p>2    HEADERS_RECEIVED    send()方法已经调用，且能获取状态行和响应头</p>
<p>3    LOADING    响应体下载中，responseText属性可能已经包含部分数据</p>
<p>4    DONE    响应体下载完成，可以直接使用responseText</p>
<p>0-4    初始化-建立连接-接收响应头-响应体下载中-加载完成</p>
]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2020/04/12/js/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包</strong>：能够读取其它函数内部变量的函数（将函数内部和函数外部连接起来的桥梁）</p>
<p><strong>闭包的作用</strong>：延长局部变量的生命周期</p>
<h1 id="检测闭包"><a href="#检测闭包" class="headerlink" title="检测闭包"></a>检测闭包</h1><p><strong>1、外层函数和内层函数</strong></p>
<p><strong>2、外层函数必须有局部变量</strong></p>
<p><strong>3、子函数能够操作外层函数的局部变量</strong></p>
<p><strong>4、子函数和外部产生关联</strong></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><strong>1、变量的生命周期</strong>：生：变量何时在内存中开辟一块空间。死：变量何时从内存中释放</p>
<p><strong>2、全局变量的生命周期</strong>：生：程序打开时。死：程序关闭时</p>
<p><strong>3、局部变量的生命周期</strong>：生：函数调用执行时。死：函数调用执行结束后</p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p><strong>本质</strong>：变量的查找过程（从内向外）</p>
<p><strong>全局变量：在全局作用域中，通过var关键字创建的变量</strong></p>
<p><strong>全局作用域</strong>：函数之外的执行环境</p>
<p><strong>局部作用域</strong>：函数内部的执行环境</p>
<h1 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h1><p><strong>函数调用结束后局部变量不会释放，容易造成内存泄漏</strong></p>
<pre><code>function father() {
    var a = &#39;123&#39;
    function son() {
        console.log(a)
    }
    return son
}
var abc = father()
abc()</code></pre>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>原型</title>
    <url>/2020/04/12/js/%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p><strong>原型</strong>：就是对象</p>
<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p><strong>对象中的属性值是变化的，方法的值是不变的</strong></p>
<p><strong>原因</strong>：对象中的成员越多，越消耗内存（对象中的方法重复，代码冗余）</p>
<p><strong>方案</strong>：把不变的方法放到一个地方，让所有实例对象共享（放到原型里）</p>
<h1 id="构造函数和原型的关系"><a href="#构造函数和原型的关系" class="headerlink" title="构造函数和原型的关系"></a>构造函数和原型的关系</h1><p><strong>构造函数可以通过prototype获取到原型</strong></p>
<p><strong>原型可以通过constructor找到构造函数</strong></p>
<h1 id="实例对象和原型的关系（原型链）"><a href="#实例对象和原型的关系（原型链）" class="headerlink" title="实例对象和原型的关系（原型链）"></a>实例对象和原型的关系（原型链）</h1><p><strong>原型顶级祖宗Object</strong>(任何实例对象都属于Object)</p>
<p><strong>1、实例对象先从自身查找</strong></p>
<p><strong>2、若找不到，则通过系统分配的_ <em>proto</em> _提供的原型地址进入到原型中查找，以此类推</strong></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p><strong>1、先更改子类的原型prototype指向一个父类对象</strong></p>
<p><strong>2、在原型中添加一个constructor保证关系的完整性</strong></p>
<p><strong>优缺点</strong>：可以完美继承方法，无法完美继承属性</p>
<pre><code> // 人类 → 父类
    function Person() {
      this.name = &#39;名字&#39;;
      this.age = 10;
      this.gender = &#39;男&#39;;
    }
    Person.prototype.sayHi = function () { console.log(&#39;你好&#39;); };
    Person.prototype.eat = function () { console.log(&#39;我会吃。。。&#39;); };
    Person.prototype.play = function () { console.log(&#39;我会玩&#39;); };


    // 学生类 → 子类
    function Student() {
      this.stuId = 1000;
    }
    // 子类的原型prototyp指向父类的一个实例对象
    Student.prototype = new Person();
    // 添加一个constructor成员
    Student.prototype.constructor = Student;

    // 如何实现原型继承：
    // 给子类的原型prototype重新赋值为父类的一个实例对象。
    // 利用了原型链上属性或方法的查找规则。


    // 创建一个学生对象
    var stu1 = new Student();
    console.log(stu1.constructor)</code></pre><h2 id="借用继承"><a href="#借用继承" class="headerlink" title="借用继承"></a>借用继承</h2><p><strong>通过call方法</strong></p>
<p>函数名.call（调用者，实参1，实参2…)</p>
<p><strong>优缺点</strong>：可以完美继承属性，无法完美继承方法</p>
<pre><code>    // 人类 → 父类
    function Person(name,age,gender) {
      this.name = name;
      this.age = age;
      this.gender = gender;
    }
    Person.prototype.sayHi = function () { console.log(&#39;你好&#39;); };
    Person.prototype.eat = function () { console.log(&#39;我会吃。。。&#39;); };
    Person.prototype.play = function () { console.log(&#39;我会玩&#39;); };


    // 学生类 → 子类
    function Student(name,age,gender,stuId) {
      // this关键字代表谁,代表的是一个学生对象，当前创建的对象 stu1 ,stu2
      // var obj = this;
      //【借用继承】
      // Person.call(obj,name,age,gender);
      Person.call(this,name,age,gender);
      this.stuId = stuId;
    }


    // 创建第一个学生对象
    var stu1 = new Student(&#39;张三&#39;,10,&#39;男&#39;,10086);
    // 创建第二个学生对象
    var stu2 = new Student(&#39;李四&#39;,11,&#39;女&#39;,10010);</code></pre><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p><strong>原型继承+借用继承</strong></p>
<pre><code>    // 人类 → 父类
    function Person(name,age,gender) {
      this.name = name;
      this.age = age;
      this.gender = gender;
    }
    Person.prototype.sayHi = function () { console.log(&#39;你好&#39;); };
    Person.prototype.eat = function () { console.log(&#39;我会吃。。。&#39;); };
    Person.prototype.play = function () { console.log(&#39;我会玩&#39;); };


    // 学生类 → 子类
    function Student(name,age,gender,stuId) {
      //【借用继承】
      Person.call(this,name,age,gender);
      this.stuId = stuId;
    }

    // 【原型继承】
    Student.prototype = new Person();
    Student.prototype.constructor = Student;


    // 创建第一个学生对象
    var stu1 = new Student(&#39;张三&#39;,10,&#39;男&#39;,10086);
    // 创建第二个学生对象
    var stu2 = new Student(&#39;李四&#39;,11,&#39;女&#39;,10010);</code></pre>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向</title>
    <url>/2020/04/12/js/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><p><strong>普通函数</strong>: this指向window（直接调用）</p>
<p><strong>定时器</strong>:  this指向window</p>
<p><strong>方法中的this</strong>:  指向调用者</p>
<p><strong>构造函数</strong>:  this指向当前创建的对象（当前开辟的空间）</p>
<p><strong>事件处理程序</strong>:  this指向事件源</p>
<h1 id="构造函数和普通函数区别"><a href="#构造函数和普通函数区别" class="headerlink" title="构造函数和普通函数区别"></a>构造函数和普通函数区别</h1><p><strong>普通函数</strong>:  直接调用</p>
<p><strong>构造函数</strong>:  new关键字调用</p>
<h1 id="new关键字的执行过程"><a href="#new关键字的执行过程" class="headerlink" title="new关键字的执行过程"></a>new关键字的执行过程</h1><p><strong>1、向内存中申请一块空间用来存放对象（此时对象中没有属性和方法）</strong></p>
<p><strong>2、进入构造函数中，this关键字指向当前开辟的空间</strong></p>
<p><strong>3、通过this关键字，向内存空间中的对象添加属性和方法</strong></p>
<p><strong>4、把this返回给外部接收的变量（将new关键字创建好的对象赋值给变量）</strong></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序封装通用的接口调用</title>
    <url>/2020/04/10/wxprogram/request/</url>
    <content><![CDATA[<h1 id="封装request-js"><a href="#封装request-js" class="headerlink" title="封装request.js"></a>封装request.js</h1><pre><code>// 封装通用的接口调用方法
// const qs = require(&#39;qs&#39;)
export default (path, param, method, header) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // let baseUrl = `http://baidu.com:8001/${path}`
    let defaultMethod = &#39;get&#39;
    if (method) {
      // 如果第三个参数传递了就覆盖默认请求方式，否则使用默认值
      defaultMethod = method
      // param = qs.stringify(param)
    }
    mpvue.request({
      url: baseUrl,
      data: param,
      method: defaultMethod,
      header: header,
      success: (res) =&gt; {
        if (res.data.success) {
          // 处理响应结果
          // resolve(res.data.body)
          resolve(res.data)
        } else {
          reject(res.data.errmsg)
        }
      }
    })
  })
}
</code></pre>]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>时间格式化</title>
    <url>/2020/04/10/js/js%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<h1 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h1><p>utils/index.js</p>
<pre><code>export function formatDateTime (date) {
  var y = date.getFullYear()
  var m = date.getMonth() + 1
  m = m &lt; 10 ? (&#39;0&#39; + m) : m
  var d = date.getDate()
  d = d &lt; 10 ? (&#39;0&#39; + d) : d
  var h = date.getHours()
  h = h &lt; 10 ? (&#39;0&#39; + h) : h
  var minute = date.getMinutes()
  minute = minute &lt; 10 ? (&#39;0&#39; + minute) : minute
  var second = date.getSeconds()
  second = second &lt; 10 ? (&#39;0&#39; + second) : second
  return y + &#39;/&#39; + m + &#39;/&#39; + d + &#39; &#39; + h + &#39;:&#39; + minute + &#39;:&#39; + second
}</code></pre><p><strong>使用</strong></p>
<pre><code>import { formatDateTime } from &#39;@/utils/index.js</code></pre><p><strong>vue中使用(过滤器</strong></p>
<pre><code>filter: {
    formatDateTime(date) {
        var date = new Date(date)
        return formatDateTime(date)
    }
}</code></pre><pre><code>&lt;span&gt;{{createTime|formatDateTime}}</code></pre><p><strong>mpvue小程序中使用</strong></p>
<pre><code>import { formatDateTime } from &#39;@/utils/index.js</code></pre><pre><code>this.questionDetails = this.questionDetails.map(item =&gt; {
   item.TimeSpan = formatDate(new Date(item.TimeSpan), &#39;yyyy-MM-dd hh:mm:ss&#39;)
        return item
})</code></pre><h1 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h1><p>utils/index.js</p>
<pre><code>
export function formatDate (date, fmt) {
  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &#39;&#39;).substr(4 - RegExp.$1.length))
  }
  let o = {
    &#39;M+&#39;: date.getMonth() + 1,
    &#39;d+&#39;: date.getDate(),
    &#39;h+&#39;: date.getHours(),
    &#39;m+&#39;: date.getMinutes(),
    &#39;s+&#39;: date.getSeconds()
  }
  for (let k in o) {
    if (new RegExp(`(${k})`).test(fmt)) {
      let str = o[k] + &#39;&#39;
      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str))
    }
  }
  return fmt
}

function padLeftZero (str) {
  return (&#39;00&#39; + str).substr(str.length)
}</code></pre><p><strong>使用 （yyyy-MM-dd hh:mm:ss可自定义）</strong></p>
<pre><code>import { formatDateTime, formatDate } from &#39;@/utils/index.js</code></pre><pre><code>filter: {
    formatDateTime(date) {
        var date = new Date(date)
        return formatDateTime(date, &#39;yyyy-MM-dd hh:mm:ss&#39;)
    }
}</code></pre>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>css半圆</title>
    <url>/2020/04/02/css/css%E5%8D%8A%E5%9C%86/</url>
    <content><![CDATA[<h1 id="弧"><a href="#弧" class="headerlink" title="弧"></a>弧</h1><pre><code>.angel {
    margin: 100px auto;
    width: 100px;
    height: 100px;
    background-color: gold;
    border-top-left-radius: 100px;
    border: 2px solid red;
    border-right: 0;
    transform: rotate(45deg);
    border-bottom: 0;
}</code></pre>]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>小程序自定义tabbar</title>
    <url>/2020/04/02/wxprogram/tabbar/</url>
    <content><![CDATA[<h1 id="app-json配置-“custom”-true"><a href="#app-json配置-“custom”-true" class="headerlink" title="app.json配置     “custom”: true,"></a>app.json配置     “custom”: true,</h1><pre><code>&quot;tabBar&quot;: {
    &quot;custom&quot;: true,
    &quot;color&quot;: &quot;#999&quot;,
    &quot;backgroundColor&quot;: &quot;#ffffff&quot;,
    &quot;selectedColor&quot;: &quot;#2a7ffb&quot;,
    &quot;borderStyle&quot;: &quot;black&quot;,

    &quot;list&quot;: [{</code></pre><h1 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h1><h2 id="tabbar-tabbar-vue"><a href="#tabbar-tabbar-vue" class="headerlink" title="tabbar/tabbar.vue"></a>tabbar/tabbar.vue</h2><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div class=&quot;tabbar&quot; @click.stop=&quot;handleTabbar&quot;&gt;
      &lt;div class=&quot;tab-bar-border&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;tab-bar-item index&quot; data-index=&quot;1&quot;&gt;
        &lt;cover-image data-index=&quot;1&quot; :src=&quot;selectedTabbar === 1 ? &#39;/static/tabs/home-active.jpg&#39; : &#39;/static/tabs/home.jpg&#39;&quot; class=&quot;_cover-image&quot;&gt;
        &lt;/cover-image&gt;
        &lt;cover-view data-index=&quot;1&quot; :style=&quot;{color: selectedTabbar === 1 ? selectedColor : color}&quot;&gt;首页&lt;/cover-view&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tab-bar-item editText&quot; data-index=&quot;2&quot;&gt;
        &lt;cover-view data-index=&quot;2&quot; :style=&quot;{color: selectedTabbar === 2 ? selectedColor : color}&quot;&gt;编辑&lt;/cover-view&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tab-bar-item my&quot; data-index=&quot;3&quot;&gt;
        &lt;cover-image data-index=&quot;3&quot; :src=&quot;selectedTabbar === 3 ? &#39;/static/tabs/my-active.jpg&#39; : &#39;/static/tabs/my.jpg&#39;&quot; class=&quot;_cover-image&quot;&gt;
        &lt;/cover-image&gt;
        &lt;cover-view data-index=&quot;3&quot; :style=&quot;{color: selectedTabbar === 3 ? selectedColor : color}&quot;&gt;我的&lt;/cover-view&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;edit&quot; data-index=&quot;2&quot;&gt;
      &lt;cover-image data-index=&quot;2&quot; :src=&quot;selectedTabbar === 2 ? &#39;/static/tabs/edit-active.jpg&#39; : &#39;/static/tabs/edit.jpg&#39;&quot; class=&quot;_cover-image&quot;&gt;
      &lt;/cover-image&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    props: [ &#39;selectedTabbar&#39; ],
    data () {
      return {
        color: &#39;#7A7E83&#39;,
        selectedColor: &#39;#2a7ffb&#39;
      }
    },
    created () {
    },
    updated () {
      // console.log(this.selectedTabbar)
    },
    mounted () {
    },
    methods: {
      handleTabbar (e) {
        this.selectedTabbar = parseInt(e.target.dataset.index)
        this.$emit(&#39;selectTab&#39;, this.selectedTabbar)
        if (this.selectedTabbar === 1) {
          wx.switchTab({
            url: &#39;/pages/index/main&#39;
          })
        } else if (this.selectedTabbar === 2) {
          wx.switchTab({
            url: &#39;/pages/edit/main&#39;
          })
        } else if (this.selectedTabbar === 3) {
          wx.switchTab({
            url: &#39;/pages/my/main&#39;
          })
        }
      }
    },
    computed: {
    }
  }
&lt;/script&gt;
&lt;style scoped lang=&quot;less&quot;&gt;
.tabbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 48px;
  background: white;
  // display: flex;
  // padding-bottom: env(safe-area-inset-bottom);
}
.tab-bar-border {
  background-color: rgba(0, 0, 0, 0.33);
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 1px;
  transform: scaleY(0.5);
}

// .tab-bar-item {
//   flex: 1;
//   text-align: center;
//   display: flex;
//   justify-content: center;
//   align-items: center;
//   flex-direction: column;
// }
.index {
  position: absolute;
  // top: 15rpx;
  width: 50rpx;
  height: 100rpx;
  padding: 15rpx 100rpx;
}
.tab-bar-item cover-image {
  width: 40rpx;
  height: 40rpx;
}

.tab-bar-item cover-view {
  margin-top: 8rpx;
  font-size: 10px;
}
.editText {
  position: absolute;
  left: 258rpx;
  padding: 50rpx 100rpx;
}
.my {
  position: absolute;
  width: 50rpx;
  left: 500rpx;
  padding: 15rpx 100rpx;
}
.edit {
  position: fixed;
  width: 90rpx;
  height: 90rpx;
  left: 320rpx;
  bottom: 40rpx;
  padding: 10rpx;
  background: #fff;
  border: 1rpx solid #fff;
  border-radius: 50%;
}
&lt;/style&gt;</code></pre><h2 id="tabbar-main-json"><a href="#tabbar-main-json" class="headerlink" title="tabbar/main.json"></a>tabbar/main.json</h2><pre><code>{
    &quot;component&quot;: true
}</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="index-main-json"><a href="#index-main-json" class="headerlink" title="index/main.json"></a>index/main.json</h2><pre><code>{
    &quot;usingComponents&quot;: {}
}
</code></pre><h2 id="index-index-vue"><a href="#index-index-vue" class="headerlink" title="index.index.vue"></a>index.index.vue</h2><pre><code>import tabBar from &#39;@/components/tabBar/tabbar&#39;
export default {
  components: { tabBar },
  data () {
    return {
      selectedTabbar: 1
    }
  }
 }</code></pre><pre><code>&lt;tab-bar :selectedTabbar=&quot;selectedTabbar&quot; @selectTab=&quot;handleTab&quot;&gt;&lt;/tab-bar&gt;</code></pre><pre><code>handleTab (index) {
    this.selectedTabbar = index
},</code></pre><h1 id="index改变图片和字体不跟随变动"><a href="#index改变图片和字体不跟随变动" class="headerlink" title="index改变图片和字体不跟随变动"></a>index改变图片和字体不跟随变动</h1><pre><code>updated () {
    this.selectedTabbar = 1
},</code></pre>]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>tabbar</tag>
      </tags>
  </entry>
  <entry>
    <title>vue和webpack</title>
    <url>/2020/03/30/webpack/vue%E5%92%8Cwebpack/</url>
    <content><![CDATA[<h1 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h1><pre><code>npm install -g @vue/cli</code></pre><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><pre><code>vue init webpack 项目名</code></pre><h1 id="配置node-sass"><a href="#配置node-sass" class="headerlink" title="配置node-sass"></a>配置node-sass</h1><pre><code>npm i node-sass style-loader --save-dev
npm install sass-loader@7.3.1 --save-dev</code></pre><p>webpack.base.config.js</p>
<pre><code>{
    test: /\.sass$/,
    loaders: [&#39;style&#39;, &#39;css&#39;, &#39;sass&#39;]
}</code></pre>]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序吸顶效果</title>
    <url>/2020/03/28/wxprogram/%E5%90%B8%E9%A1%B6/</url>
    <content><![CDATA[<h1 id="小程序吸顶效果"><a href="#小程序吸顶效果" class="headerlink" title="小程序吸顶效果"></a>小程序吸顶效果</h1><pre><code>&lt;div class=&quot;tabs&quot; :class=&quot;scrollTop &gt; 0 ? &#39;groupPosition&#39; : &#39;&#39;&quot; @click=&quot;changeTab&quot;&gt;
    &lt;div data-index=&#39;1&#39; class=&quot;tab all&quot; :class=&quot;currentIndex === 1?&#39;current&#39;:&#39;&#39;&quot;&gt;全部&lt;/div&gt;
    &lt;div data-index=&#39;2&#39; class=&quot;tab handle&quot; :class=&quot;currentIndex === 2?&#39;current&#39;:&#39;&#39;&quot;&gt;处理中&lt;/div&gt;
    &lt;div data-index=&#39;3&#39; class=&quot;tab complete&quot; :class=&quot;currentIndex===3?&#39;current&#39;:&#39;&#39;&quot;&gt;已完成&lt;/div&gt;
&lt;/div&gt;</code></pre><pre><code>mounted () {
},
onPageScroll (e) {
  this.scrollTop = e.scrollTop
},</code></pre><p>css</p>
<pre><code>.groupPosition {
    position: fixed;
}</code></pre>]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序基本使用</title>
    <url>/2020/03/28/wxprogram/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="小程序吸顶效果"><a href="#小程序吸顶效果" class="headerlink" title="小程序吸顶效果"></a>小程序吸顶效果</h1><pre><code>&lt;div class=&quot;tabs&quot; :class=&quot;scrollTop &gt; 0 ? &#39;groupPosition&#39; : &#39;&#39;&quot; @click=&quot;changeTab&quot;&gt;
    &lt;div data-index=&#39;1&#39; class=&quot;tab all&quot; :class=&quot;currentIndex === 1?&#39;current&#39;:&#39;&#39;&quot;&gt;全部&lt;/div&gt;
    &lt;div data-index=&#39;2&#39; class=&quot;tab handle&quot; :class=&quot;currentIndex === 2?&#39;current&#39;:&#39;&#39;&quot;&gt;处理中&lt;/div&gt;
    &lt;div data-index=&#39;3&#39; class=&quot;tab complete&quot; :class=&quot;currentIndex===3?&#39;current&#39;:&#39;&#39;&quot;&gt;已完成&lt;/div&gt;
&lt;/div&gt;</code></pre><pre><code>mounted () {
},
onPageScroll (e) {
  this.scrollTop = e.scrollTop
},</code></pre><p>css</p>
<pre><code>.groupPosition {
    position: fixed;
}</code></pre><h1 id="小程序tab栏切换效果"><a href="#小程序tab栏切换效果" class="headerlink" title="小程序tab栏切换效果"></a>小程序tab栏切换效果</h1><p>css</p>
<pre><code>.tabs {
    display: flex;
    flex: 1;
    z-index: 100;
    width: 100%;
    background: #fff;
    border-bottom: 1px solid #ccc;
    margin-bottom: 50rpx;
    .tab {
        padding:20rpx 47rpx;
    }
    .current {
        color: #EF4238;
        border-bottom: 1px solid #EF4238;
     }
}</code></pre><p>js</p>
<pre><code>changeTab (e) {
    let index = parseInt(e.target.dataset.index)
    this.currentIndex = index
}</code></pre><h1 id="小程序自定义下拉框"><a href="#小程序自定义下拉框" class="headerlink" title="小程序自定义下拉框"></a>小程序自定义下拉框</h1><p>data</p>
<pre><code>selectItem: &#39;点击选择项目&#39;,
selectProject: false,
projectItem: [ &#39;你好1&#39;, &#39;你好2&#39;, &#39;你好3&#39; ],</code></pre><p>html</p>
<pre><code>&lt;div class=&#39;top&#39;&gt;
    &lt;div class=&#39;top-text&#39;&gt; 选择项目&lt;/div&gt;
    &lt;!-- 下拉框 --&gt;
    &lt;div class=&#39;top-selected&#39; @click=&#39;handleProject&#39;&gt;
    &lt;span class=&quot;select-top&quot;&gt;{{selectItem}}&lt;/span&gt;
    &lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;
    &lt;/div&gt;
    &lt;!-- 下拉需要显示的列表 --&gt;
    &lt;span class=&quot;san&quot; v-if=&quot;selectProject&quot;&gt;&lt;/span&gt;
    &lt;div class=&quot;select_box&quot; v-if=&quot;selectProject&quot;&gt;
    &lt;div v-for=&quot;(item, index) in projectItem&quot; :key=&quot;index&quot;&gt;
    &lt;div class=&quot;select_one&quot; @click=&quot;mySelect&quot; :data-name=&quot;item&quot;&gt;{{item}}&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre><p>js</p>
<pre><code>handleProject () {
   this.selectProject = !this.selectProject
},
mySelect (e) {
    var select = e.currentTarget.dataset.name
    this.selectItem = select
}</code></pre><p>css</p>
<pre><code>.top {
    position: relative;
    width: 100%;
    height: 80rpx;
    line-height: 80rpx;
    font-size: 34rpx;
    border-bottom: 1px solid #000;
    .top-text {
        float: left;
        width: 45%;
        padding-left: 20rpx;
    }
    .top-selected {
        width: 52%;
        display: flex;
        float: right;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid #ccc;
        border-left: 1px solid #ccc;
        font-size: 30rpx;
        .select-top {
            padding-left: 50rpx;
        }
        .icon {
            width: 20rpx;
            height: 20rpx;
            margin-right: 50rpx;
            border-bottom: 2rpx solid #000;
            border-right: 2rpx solid #000;
            transform: rotate(45deg);
        }
    }
      /* 下拉内容 */
    .san {
        position: absolute;
        left: 420rpx;
        top: 118rpx;
        width: 35rpx;
        height: 35rpx;
        margin-right: 50rpx;
        border-top: 2rpx solid #ddd;
        border-left: 2rpx solid #ddd;
        border-bottom: 2rpx solid #fff;
        box-shadow: 2rpx #eee;
        background:#fff;
        transform: rotate(45deg);
        z-index: 10;
    }
    .select_box {
        background-color: #fff;
        width: 46%;
        float: right;
        position: absolute;
        right: 10rpx;
        top: 86rpx;
        z-index: 1;
        overflow: hidden;
        text-align: left;
        animation: myfirst 0.5s;
        font-size: 32rpx;
        border: 5rpx solid #eee;
        box-shadow: 2rpx #eee;
        margin-top: 50rpx;
        padding-left: 20rpx;
        .select_one {
            width: 100%;
            height: 75rpx;
            line-height: 75rpx;
        }
      }
    }</code></pre><h1 id="小程序授权"><a href="#小程序授权" class="headerlink" title="小程序授权"></a>小程序授权</h1><p><strong>mpvue若授权时将用户信息存在缓存，并调用接口，不能在update中更新用户信息，更新即销毁，拿不到用户信息，应该在onLoad和onShow中更新</strong></p>
<p>app.vue</p>
<pre><code>onLaunch () {
    wx.login({
      success: res =&gt; {
        //       // 发送 res.code 到后台换取 openId, sessionKey, unionId
        if (res.code) {
          this.code = res.code
          this.wxGetUserInfo()
        }
      }
    })
    // 获取用户信息
    wx.getSetting({
      success: res =&gt; {
        // console.log(res)
        if (res.authSetting[&#39;scope.userInfo&#39;]) {
          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框
          wx.getUserInfo({
            success: res =&gt; {
              // 可以将 res 发送给后台解码出 unionId
              this.userInfo = res.userInfo
              wx.setStorageSync(&#39;userInfo&#39;, res.userInfo)
              // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回
              // 所以此处加入 callback 以防止这种情况
              if (this.userInfoReadyCallback) {
                this.userInfoReadyCallback(res)
              }
            }
          })
        }
      }
    })
  },</code></pre><pre><code>wxGetUserInfo () {
      wx.request({
        url: `http://39.107.35.106:8001/api/Auth`,
        method: &#39;get&#39;,
        data: {
          code: this.code
        },
        header: {
          &#39;content-type&#39;: &#39;application/json&#39;
        },
        success: (res) =&gt; {
          // console.log(res.data)
        }
      })
    }</code></pre><p>user/index.vue</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;!--index.wxml--&gt;
    &lt;view class=&quot;container&quot;&gt;
      &lt;view class=&quot;userinfo&quot;&gt;
        &lt;button v-if=&quot;!hasUserInfo &amp;&amp; canIUse&quot; open-type=&quot;getUserInfo&quot; @getuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt;
        &lt;block wx:else&gt;
          &lt;image @click=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; :src=&quot;userInfo.avatarUrl&quot; mode=&quot;cover&quot;&gt;&lt;/image&gt;
          &lt;text class=&quot;userinfo-nickname&quot;&gt;{{userInfo.nickName}}&lt;/text&gt;
        &lt;/block&gt;
      &lt;/view&gt; 
    &lt;/view&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data () {
    return {
      userInfo: {},
      hasUserInfo: false,
      canIUse: mpvue.canIUse(&#39;button.open-type.getUserInfo&#39;)
    }
  },
  methods: {
    bindViewTap () {
      wx.getSetting({
        success (res) {
          if (!res.authSetting[&#39;scope.record&#39;]) {
            wx.switchTab({
              url: &#39;/pages/index/main&#39;
            })
            // mpvue.authorize({
            //   scope: &#39;scope.record&#39;,
            //   success () {
            //   // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问
            //     wx.startRecord()
            //   }
            // })
          }
        }
      })
    },
    getUserInfo () {
      // 调用登录接口
      mpvue.getUserInfo({// 当已授权getUserInfo时
        success: res =&gt; {
          // console.log(res.userInfo)
          this.userInfo = res.userInfo
          wx.setStorageSync(&#39;userInfo&#39;, res.userInfo)
          this.hasUserInfo = true
          wx.switchTab({
            url: &#39;/pages/index/main&#39;
          })
        },
        fail: (err) =&gt; {
          console.log(err)
        }
      })
    }
  }
}
&lt;/script&gt;

&lt;style scoped lang=&quot;less&quot;&gt;
  @import &#39;./main.less&#39;;
&lt;/style&gt;
</code></pre><h1 id="页面内的转发分享功能"><a href="#页面内的转发分享功能" class="headerlink" title="页面内的转发分享功能"></a>页面内的转发分享功能</h1><pre><code>onShareAppMessage () {
    return {
      title: &#39;转发&#39;,
      path: &#39;/pages/index/index&#39;,
      success: function (res) {}
    }
  },
  created () {}</code></pre><h1 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h1><p><strong>后台返回的图片路径必须是<a href="http://123/a.jpg这种形式，斜杠方向一致，不然图片不能展示" target="_blank" rel="noopener">http://123/a.jpg这种形式，斜杠方向一致，不然图片不能展示</a></strong></p>
<pre><code>&lt;div class=&quot;addImg&quot;&gt;
    &lt;div class=&quot;ImgTitle&quot;&gt;添加图片&lt;/div&gt;
    &lt;div class=&quot;img&quot; v-if=&quot;tempFilePaths&quot;&gt;
    &lt;span class=&quot;left&quot; @tap=&quot;handleToBig(item)&quot; v-for=&quot;(item, index) in tempFilePathss&quot; :key=&quot;index&quot;&gt;
        &lt;img :src=&quot;item&quot; alt=&quot;&quot;&gt;
    &lt;/span&gt;
    &lt;div class=&quot;right&quot; @click=&quot;handleImg&quot;&gt;
        &lt;img class=&quot;imgIcon&quot; src=&quot;../../../static/images/add.jpg&quot; alt=&quot;&quot;&gt;
     &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre><pre><code>handleImg () {
      wx.chooseImage({
        count: 9,
        sizeType: [&#39;original&#39;, &#39;compressed&#39;],
        sourceType: [&#39;album&#39;, &#39;camera&#39;],
        success: (res) =&gt; {
          // tempFilePath可以作为img标签的src属性显示图片
          this.ImgFilePaths = res.tempFilePaths
          console.log(this.ImgFilePaths)
        }
      })
    },</code></pre><pre><code>    handleImg () {
      mpvue.chooseImage({
        count: 9,
        sizeType: [&#39;original&#39;, &#39;compressed&#39;],
        sourceType: [&#39;album&#39;, &#39;camera&#39;],
        success: (res) =&gt; {
          this.tempFilePaths = [...res.tempFilePaths]
          this.tempFilePathss = [...this.tempFilePathss, ...res.tempFilePaths]
          // console.log(this.tempFilePaths)
          mpvue.showToast({
            title: &#39;正在上传...&#39;,
            icon: &#39;loading&#39;
          })
          this.tempFilePaths.forEach(item =&gt; {
            mpvue.uploadFile({
              url: &#39;http://39.107.35.106:8001/api/file/Post&#39;,
              filePath: item,
              name: &#39;file&#39;,
              header: {
                &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;
              },
              success: (res) =&gt; {
                // console.log(JSON.parse(res.data))
                // this.ImgFilePaths = res.data
                console.log(res.data)
                this.ImgFilePaths = [...this.ImgFilePaths, ...(JSON.parse(res.data))]
                console.log(this.ImgFilePaths)
              },
              fail: (err) =&gt; {
                console.log(err)
              }
            })
          })
          mpvue.hideToast()
        }
      })
    }</code></pre><h1 id="视频上传"><a href="#视频上传" class="headerlink" title="视频上传"></a>视频上传</h1><pre><code>&lt;div class=&quot;addVedio&quot;&gt;
    &lt;div class=&quot;vedioTitle&quot;&gt;添加视频&lt;/div&gt;
    &lt;div class=&quot;vedio&quot; v-if=&quot;VedioFilePaths.length !== 0&quot;&gt;
        &lt;span v-for=&quot;(item, index) in VedioFilePathss&quot; :key=&quot;index&quot;&gt;
            &lt;video id=&quot;myVideo&quot; class=&quot;vedioFile&quot; :src=&quot;item&quot; alt=&quot;&quot;/&gt;
        &lt;/span&gt;
    &lt;/div&gt;
    &lt;div class=&quot;bottom&quot; @click=&quot;handleVedio&quot;&gt;
        &lt;img src=&quot;../../../static/images/add.jpg&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre><pre><code>handleVedio () {
      wx.chooseVideo({
        sourceType: [&#39;album&#39;, &#39;camera&#39;],
        maxDuration: 60,
        camera: &#39;back&#39;,
        success: (res) =&gt; {
          this.VedioFilePaths = res.tempFilePath
          console.log(this.VedioFilePaths)
        },
        fail: (err) =&gt; {
          console.log(err)
        }
      })
    },</code></pre><pre><code>handleVedio () {
      mpvue.chooseVideo({
        sourceType: [&#39;album&#39;, &#39;camera&#39;],
        maxDuration: 60,
        camera: &#39;back&#39;,
        success: (res) =&gt; {
          // this.VedioFilePath = res.tempFilePath
          // console.log(res)
          this.VedioFilePaths = []
          this.VedioFilePaths.push(res.tempFilePath)
          this.VedioFilePathss.push(res.tempFilePath)
          console.log(this.VedioFilePaths)
          mpvue.showToast({
            title: &#39;正在上传...&#39;,
            icon: &#39;loading&#39;
          })
          this.VedioFilePaths.forEach(item =&gt; {
          // console.log(item)
            mpvue.uploadFile({
              url: &#39;http://39.107.35.106:8001/api/file/Post&#39;,
              filePath: item,
              name: &#39;file&#39;,
              header: {
                &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;
              },
              success: (res) =&gt; {
              // do something
                // console.log(res.data)
                this.VedioFilePath = [...this.VedioFilePath, ...JSON.parse(res.data)]
                console.log(this.VedioFilePath)
              },
              fail: (err) =&gt; {
                console.log(err)
              }
            })
          })
          mpvue.hideToast()
        },
        fail: (err) =&gt; {
          console.log(err)
        }
      })
    },</code></pre><h1 id="小程序提示更新"><a href="#小程序提示更新" class="headerlink" title="小程序提示更新"></a>小程序提示更新</h1><pre><code>onLaunch () {
    if (wx.canIUse(&#39;getUpdateManager&#39;)) {
      const updateManager = wx.getUpdateManager()
      updateManager.onCheckForUpdate(function (res) {
        // 请求完新版本信息的回调
        if (res.hasUpdate) {
          updateManager.onUpdateReady(function () {
            wx.showModal({
              title: &#39;更新提示&#39;,
              content: &#39;新版本已经上线啦~，为了获得更好的体验，建议立即更新&#39;,
              showCancel: false,
              confirmColor: &#39;#5677FC&#39;,
              success: function (res) {
                // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
                updateManager.applyUpdate()
              }
            })

            wx.setTabBarBadge({
              index: 1,
              text: &#39;new&#39;
            })
          })
          updateManager.onUpdateFailed(function () {
            // 新的版本下载失败
            wx.showModal({
              title: &#39;更新失败&#39;,
              content: &#39;新版本更新失败，为了获得更好的体验，请您删除当前小程序，重新搜索打开&#39;,
              confirmColor: &#39;#5677FC&#39;,
              showCancel: false
            })
          })
        }
      })
    } else {
      // 当前微信版本过低，无法使用该功能
      wx.showModal({
        title: &#39;提示&#39;,
        content:
          &#39;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&#39;
      })
    }
}</code></pre><h1 id="返回页面更新数据"><a href="#返回页面更新数据" class="headerlink" title="返回页面更新数据"></a>返回页面更新数据</h1><p><strong>在onLoad和onShow中需同时获取数据</strong></p>
<pre><code>  onLoad () {
    // this.widheight = wx.getSystemInfoSync().windowHeight - 220
    this.getQuestionDetails()
    this.getProductProjects()
  },
  onShow () {
    this.getQuestionDetails()
    this.getProductProjects()
  },</code></pre><h1 id="获取图片和视频是字符串格式的页面渲染需转数组"><a href="#获取图片和视频是字符串格式的页面渲染需转数组" class="headerlink" title="获取图片和视频是字符串格式的页面渲染需转数组"></a>获取图片和视频是字符串格式的页面渲染需转数组</h1><pre><code>this.questionDetailInfos = this.questionDetailInfos.filter(item =&gt; {
    if (item.PictureUrl !== &#39;&#39;) {
        item.PictureUrl = JSON.parse(item.PictureUrl)
    }
    if (item.VideoUrl !== &#39;&#39;) {
        item.VideoUrl = JSON.parse(item.VideoUrl)
    }
    return item
})</code></pre><h1 id="页面跳转传参"><a href="#页面跳转传参" class="headerlink" title="页面跳转传参"></a>页面跳转传参</h1><pre><code>mpvue.navigateTo({
     url: &#39;/pages/question_detail/main?questionid=&#39; + item.QuestionID +&#39;&amp;userid=&#39; + userid
})</code></pre><h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><pre><code>&lt;input :value=&quot;searchKeywords&quot; class=&quot;search_input&quot; type=&quot;text&quot; placeholder=&quot;请输入搜索内容&quot; @input=&quot;handleSearch&quot;&gt;</code></pre><p><strong>不能直接获取到value</strong></p>
<p>mpvue中</p>
<pre><code class="js">async handleSearch (e) {
    this.Keywords = e.target.value       // searchKeywords传给接口
},</code></pre>
<p>搜索使用函数防抖</p>
<pre><code class="js">async handleSearch (e) {
    const userid = mpvue.getStorageSync(&#39;UserInfo&#39;).UserID
    clearTimeout(this.timer)
    this.timer = setTimeout(async () =&gt; {
        if (this.searchKeywords !== &#39;&#39;) {
            let res = await request(&#39;/api/Question/Projects&#39;, {userid: userid, projectName: this.searchKeywords})
            if (res.success) {
                this.searchDetail = res.body
            }
        } else {
            this.searchDetail = []
        }
    }, 300)
},</code></pre>
<p>原生</p>
<pre><code class="js">async handleSearch (e) {
    this.searchKeywords = e.detail.value
},</code></pre>
<h1 id="防止快速点击触发多次调用"><a href="#防止快速点击触发多次调用" class="headerlink" title="防止快速点击触发多次调用"></a>防止快速点击触发多次调用</h1><pre><code>editFlag: true</code></pre><p>请求中</p>
<pre><code class="js">if (editFlag) {
    this.editFlag = false
    let res = await updateQuestion(&#39;/api/updateQuestion&#39;, param)
    if (res.success) {
        mpvue.showToast({
            title: &#39;提交成功&#39;,
            icon: &#39;none&#39;
        })
        this.editFlag = true
    } else {
        //  
    }
} </code></pre>
<h1 id="小程序转义换行"><a href="#小程序转义换行" class="headerlink" title="小程序转义换行"></a>小程序转义换行</h1><p><strong>使用text组件</strong></p>
<pre><code>&lt;text class=&quot;pro_detai_con descripbe_con&quot;&gt;{{description}}&lt;/text&gt;</code></pre><p><strong>接收到后台的数据进行处理，后台传json格式\n，前端接收到实际上是\ \n，要处理数据</strong></p>
<pre><code>this.description = res.body.Description.replace(/\\n/g, &#39;\n&#39;)</code></pre><h1 id="使用scroll-view"><a href="#使用scroll-view" class="headerlink" title="使用scroll-view"></a>使用scroll-view</h1><p><strong>注意事项</strong></p>
<p>:scroll-left=”scrollLeft”   设置横向滚动条位置</p>
<p>item的id开头不能为数字</p>
<pre><code class="html">&lt;scroll-view 
  class=&quot;scroll_top&quot; 
  scroll-x=&quot;true&quot; 
  :scroll-left=&quot;scrollLeft&quot; 
  scroll-with-animation=&quot;true&quot;
  &gt;
  &lt;div :id=&quot;&#39;scroll-item-&#39; + -1&quot; data-index=&#39;-1&#39; class=&quot;tab all&quot; :class=&quot;currentIndex === -1?&#39;current&#39;:&#39;&#39;&quot; @click=&quot;changeTab&quot;&gt;
    全部&lt;span data-index=&#39;-1&#39; class=&quot;totalCount&quot;&gt;({{total}})&lt;/span&gt;
  &lt;/div&gt;
  &lt;div :id=&quot;&#39;scroll-item-&#39; + 0&quot; data-index=&#39;0&#39; class=&quot;tab all&quot; :class=&quot;currentIndex === 0?&#39;current&#39;:&#39;&#39;&quot; @click=&quot;changeTab&quot;&gt;
   新建&lt;span data-index=&#39;0&#39; class=&quot;totalCount&quot;&gt;({{count0}})&lt;/span&gt;
 &lt;/div&gt;
 &lt;div :id=&quot;&#39;scroll-item-&#39; + 1&quot; v-if=&quot;GroupType === 2&quot; data-index=&#39;1&#39; class=&quot;tab all&quot; :class=&quot;currentIndex === 1?&#39;current&#39;:&#39;&#39;&quot; @click=&quot;changeTab&quot;&gt;
   已接收&lt;span data-index=&#39;1&#39; class=&quot;totalCount&quot;&gt;({{count1}})&lt;/span&gt;
 &lt;/div&gt;
 &lt;div :id=&quot;&#39;scroll-item-&#39; + 2&quot; data-index=&#39;2&#39; class=&quot;tab all&quot; :class=&quot;currentIndex === 2?&#39;current&#39;:&#39;&#39;&quot; @click=&quot;changeTab&quot;&gt;
   已处理&lt;span data-index=&#39;2&#39; class=&quot;totalCount&quot;&gt;({{count2}})&lt;/span&gt;
 &lt;/div&gt;
 &lt;div :id=&quot;&#39;scroll-item-&#39; + 3&quot; data-index=&#39;3&#39; class=&quot;tab handle&quot; :class=&quot;currentIndex === 3?&#39;current&#39;:&#39;&#39;&quot; @click=&quot;changeTab&quot;&gt;
   已反馈&lt;span data-index=&#39;3&#39; class=&quot;totalCount&quot;&gt;({{count3}})&lt;/span&gt;
 &lt;/div&gt;
 &lt;div :id=&quot;&#39;scroll-item-&#39; + 4&quot; data-index=&#39;4&#39; class=&quot;tab complete&quot; :class=&quot;currentIndex === 4?&#39;current&#39;:&#39;&#39;&quot; @click=&quot;changeTab&quot;&gt;
   已关闭&lt;span data-index=&#39;4&#39; class=&quot;totalCount&quot;&gt;({{count4}})&lt;/span&gt;
 &lt;/div&gt;
&lt;/scroll-view&gt;</code></pre>
<p>css</p>
<p>隐藏滚动条，scrollview的高度大于父元素高度</p>
<p>scrollview的每一项使用display: inline-block</p>
<pre><code class="CSS">.tabs {
    position: relative;
    display: flex;
    flex: 1;
    z-index: 100;
    border-bottom: 1rpx solid #ddd;
    background: #fff;
    height: 100rpx;      //////////父元素高度
    white-space: nowrap;
    overflow: hidden;
    padding: 0 20rpx;
    .scroll_top {
        width: 100%;
        height: 120rpx;     //////////////// scrollview高度
        overflow: hidden;
        white-space: nowrap;
        z-index: 200;
    }
    .tab {
        padding: 8rpx 20rpx;
        font-size: 30rpx;
        margin-top: 21rpx;
        text-align: center;
        display: inline-block;
        .totalCount {
            font-size: 28rpx;
        }
    }
    .current {
        // color: #2a7efb;
        color: #fff;
        background: #2a7efb;
        border-radius: 30rpx;
    }
 }</code></pre>
<p>data</p>
<pre><code>moveParams: {
    scrollLeft: 0
},
scrollLeft: 0,</code></pre><p>js</p>
<pre><code class="js">// 顶部筛选
async changeTab (e) {
    let index = parseInt(e.target.dataset.index)
    this.currentIndex = index
    this.status = this.currentIndex
    this.pageIndex = 1
    this.pageSize = 5
    this.searchLoading = true
    this.searchLoadingComplete = false
    this.getQuestionDetails()
    let ele = &#39;scroll-item-&#39; + e.target.dataset.index
    this.getRect(&#39;#&#39; + ele)
},
// 点击scrollview的列表项使之移动到页面中间
getRect (ele) {
    var that = this
    var query = wx.createSelectorQuery().select(ele)
    query.boundingClientRect(function (rect) {
        // let moveParams = that.moveParams
        that.moveParams.subLeft = rect.left
        that.moveParams.subHalfWidth = rect.width / 2
        that.moveTo()
    }).exec()
},
moveTo () {
    wx.getSystemInfo({
        success: (res) =&gt; {
            this.moveParams.screenHalfWidth = res.windowWidth / 2
        }
    })
    let subLeft = this.moveParams.subLeft
    let screenHalfWidth = this.moveParams.screenHalfWidth
    let subHalfWidth = this.moveParams.subHalfWidth
    let scrollLeft = this.moveParams.scrollLeft
    let distance = subLeft - screenHalfWidth + subHalfWidth
    this.scrollLeft = scrollLeft + distance
}</code></pre>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>css选三角形</title>
    <url>/2020/03/28/css/css/</url>
    <content><![CDATA[<h1 id="空心三角"><a href="#空心三角" class="headerlink" title="空心三角"></a>空心三角</h1><pre><code>.angel {
    width: 7px;
    height: 7px;
    border-bottom: 2px solid #000;
    border-right: 2px solid #000;
    transform: rotate(45deg)
    }</code></pre><h1 id="实心三角形"><a href="#实心三角形" class="headerlink" title="实心三角形"></a>实心三角形</h1><pre><code>.angel {
    width: 0px;
    height: 0px;
    border: 20px solid #fff;
    /*border-bottom: 20px solid #f00;*/
    /*border-right: 20px solid #000;*/
    /*border-left: 20px solid #00f;*/
    border-top: 20px solid #0f0;
    }</code></pre><h1 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h1><pre><code>overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;</code></pre>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序国际化</title>
    <url>/2020/03/20/wxprogram/i18n/</url>
    <content><![CDATA[<h1 id="安装gulp-及-miniprogram-i18n-的-gulp-插件"><a href="#安装gulp-及-miniprogram-i18n-的-gulp-插件" class="headerlink" title="安装gulp 及 miniprogram-i18n 的 gulp 插件"></a>安装gulp 及 miniprogram-i18n 的 gulp 插件</h1><pre><code>npm i -D gulp @miniprogram-i18n/gulp-i18n-locales @miniprogram-i18n/gulp-i18n-wxml</code></pre><h1 id="安装国际化运行时并在开发工具”构建npm"><a href="#安装国际化运行时并在开发工具”构建npm" class="headerlink" title="安装国际化运行时并在开发工具”构建npm"></a>安装国际化运行时并在开发工具”构建npm</h1><pre><code>npm i -S @miniprogram-i18n/core</code></pre><h1 id="在项目根目录新建-gulpfile-js，并编写构建脚本"><a href="#在项目根目录新建-gulpfile-js，并编写构建脚本" class="headerlink" title="在项目根目录新建 gulpfile.js，并编写构建脚本!"></a>在项目根目录新建 gulpfile.js，并编写构建脚本!</h1>]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>mpvue框架</title>
    <url>/2020/03/19/wxprogram/wxprogram/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li>安装Node.js(版本号大于v8.9.0)</li>
<li>安装vue脚手架<ul>
<li>npm install -g @vue/cli</li>
<li>npm install -g @vue/cli-init</li>
</ul>
</li>
<li>初始化项目（最后的项目名称自定义）<ul>
<li>vue init mpvue/mpvue-quickstart mytest</li>
</ul>
</li>
<li>安装依赖包（进入到项目的目录中进行）<ul>
<li>npm install</li>
</ul>
</li>
<li>运行项目<ul>
<li>npm run dev</li>
</ul>
</li>
<li>项目要导入到小程序开发工具中，但是代码通过vscode或者sublime进行开发</li>
</ul>
<h1 id="基于mpvue的实践Tab"><a href="#基于mpvue的实践Tab" class="headerlink" title="基于mpvue的实践Tab"></a>基于mpvue的实践Tab</h1><ul>
<li>如果添加新的文件，命令行需要重启 npm run dev</li>
<li>如果修改文件的内容，不需要重启</li>
<li>在vue模板中可以使用小程序内置标签，比如view标签</li>
</ul>
<h1 id="配置less环境"><a href="#配置less环境" class="headerlink" title="配置less环境"></a>配置less环境</h1><p>装包</p>
<pre><code>npm install less less-loader -D
npm install node-sass sass-loader -D</code></pre><p>样式标签配置less</p>
<pre><code>&lt;style scoped lang=&#39;less&#39;&gt;
    @import &#39;main.less&#39;;            //一定要加 ； 号
 &lt;/style&gt;</code></pre><h1 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h1><pre><code class="html">&lt;!-- 下拉需要显示的列表 --&gt;
&lt;div class=&quot;select_con&quot;&gt;
  &lt;div class=&quot;scroll&quot;&gt;
    &lt;div data-index=&quot;-1&quot; @click=&quot;handleSelectAll($event)&quot; class=&quot;scroll_item scroll_item1&quot;&gt;全部&lt;/div&gt;
    &lt;icon class=&quot;circle1&quot; data-index=&quot;-1&quot; :class=&quot;selectItemIndex[0]===-1?&#39;current&#39;:&#39;&#39;&quot;         type=&quot;success&quot; size=&quot;25&quot; color=&quot;#3e81f3&quot;/&gt;
    &lt;div
        v-for=&quot;(item, index) in productProjectList&quot;
        :key=&quot;index&quot;
        @click.stop=&quot;handleSelectItem($event, item, index)&quot;
        class=&quot;scroll_item scroll_item1&quot;
        &gt;
        &lt;span&gt;{{item.ProjectName}}&lt;/span&gt;
        &lt;icon class=&quot;circle&quot; :class=&quot;selectedItem[index]===index?&#39;current&#39;:&#39;&#39;&quot; type=&quot;success&quot;     size=&quot;25&quot; color=&quot;#3e81f3&quot;/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
<pre><code class="js">// 选择全部    
handleSelectAll (e) {
      let index = parseInt(e.target.dataset.index)
      let indexItem = this.selectItemIndex.indexOf(index)
      if (indexItem === -1) {
        this.selectItemIndex.push(index)
      } else {
        this.selectItemIndex.splice(indexItem, 1)
      }
      this.projectID = []
      this.selectItemName = []
    },
    // 选择
    handleSelectItem (e, data, index) {
      console.log(index)
      let indexItem = this.selectedItem.indexOf(index)
      if (indexItem === -1) {
        this.index1[index] = index
        this.projectID.push(data.ProjectID)
        for (var i = 0; i &lt; this.productProjectList.length; i++) {
          if (i !== this.index1[i]) {
            this.selectedItem[i] = -1
          } else {
            this.selectedItem[i] = this.index1[i]
          }
        }
        this.selectItemName.push(data.ProjectName)
      } else {
        this.projectID.splice(indexItem, 1)
        this.index1[indexItem] = -1
        this.selectedItem[indexItem] = -1
        this.selectItemName.splice(indexItem, 1)
      }
      // console.log(this.index1)
      // console.log(this.selectedItem)
      // console.log(this.selectItemIndex)
    },</code></pre>
<pre><code class="js"> // 重置
    handleReset () {
      this.index1 = []
      this.selectItemIndex = []
      this.selectedItem = []
      this.projectID = []
      this.selectItemName = []
    },    
// 筛选确定
    async handleConfirm () {
      let check = this.selectedItem.every(item =&gt; {
        return item === -1
      })
      if (check &amp;&amp; this.selectItemIndex.length === 0) {
        mpvue.showToast({
          title: &#39;请选择所属项目&#39;,
          icon: &#39;none&#39;
        })
        return
      }
      this.selectItemNameString = this.selectItemName.toString()
      this.getQuestionDetails()
      this.index1 = []
      this.selectedItem = []
      this.selectItemIndex = []
      this.selectItemName = []
      this.selectStatus = false
    },
    // 关闭弹窗
    handleShutMask () {
      this.index1 = []
      this.selectedItem = []
      this.selectItemIndex = []
      this.selectItemName = []
      this.selectStatus = false
    },
    // 打开筛选弹窗
    handleScreen () {
      this.selectItemIndex = []
      this.selectedItem = []
      this.projectID = []
      this.selectItemName = []
      this.selectStatus = true
      // console.log(this.currentIndex)
    },</code></pre>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-echarts</title>
    <url>/2020/03/17/echarts/vue-echarts/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>webpack4打包vue文件</title>
    <url>/2020/03/13/webpack/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>npm init -y
npm i webpack -D
npm i webpack-cli -D</code></pre><h1 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h1><ul>
<li>npm run serve  在package.json  scripts配置过</li>
</ul>
<pre><code class="json">{
    &quot;scripts&quot;:{
        &quot;build&quot;:&quot;webpack&quot;
    }   
}</code></pre>
<ol>
<li>调用webpack工具</li>
</ol>
<pre><code class="bash">npm run build</code></pre>
<h1 id="webpack打包模式（mode）"><a href="#webpack打包模式（mode）" class="headerlink" title="webpack打包模式（mode）"></a>webpack打包模式（mode）</h1><ul>
<li>需要在配置文件下进行配置</li>
<li>默认的配置文件名称是：webpack.config.js</li>
</ul>
<pre><code class="js">module.exports = {
    //development 开发模式打包 打包速度快 没做优化处理
    //production 生成模式打包 打不速度慢 做了一些优化处理，压缩
    mode: &#39;development&#39;
} </code></pre>
<h1 id="webpack入口与出口"><a href="#webpack入口与出口" class="headerlink" title="webpack入口与出口"></a>webpack入口与出口</h1><ul>
<li>默认入口是 src下的index.js文件</li>
<li>默认出口是 dist 目录下的 main.js 文件</li>
</ul>
<pre><code class="js">const path = require(&#39;path&#39;);

&lt;1&gt;
module.exports = {
  // 打包的入口文件
  entry: &#39;./src/main.js&#39;,
  // 输出的出口文件
  output: {
    // 必须指定的是绝对路径
    filename: &#39;main.js&#39;
    path: path.join(__dirname, &#39;./dist&#39;),
  }
};

&lt;2&gt;
module.exports = {
  entry: &#39;./src/main.js&#39;,
    output: {
      filename: &#39;js/bundle.js&#39;,
      path: path.resolve(__dirname, &#39;./dist&#39;)
    },
}</code></pre>
<h1 id="webpack打包-vue文件"><a href="#webpack打包-vue文件" class="headerlink" title="webpack打包.vue文件"></a>webpack打包.vue文件</h1><pre><code>npm install -D vue-loader vue-template-compiler</code></pre><pre><code> const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;)

  module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
      filename: &#39;main.js&#39;,
      path: path.resolve(__dirname, &#39;dist&#39;)
    },
   module: {
     rules: [
       {
        test: /\.vue$/,
        loader: &#39;vue-loader&#39;
      },
     ]
   },
   plugins: [
    // 请确保引入这个插件！
    new VueLoaderPlugin()
  ]
  };</code></pre><h1 id="打包静态资源"><a href="#打包静态资源" class="headerlink" title="打包静态资源"></a>打包静态资源</h1><p>npm i copy-webpack-plugin -D</p>
<pre><code>const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;)

new CopyWebpackPlugin([{
    from: path.resolve(__dirname, &#39;./public/static&#39;), // 打包的静态资源目录地址
    to: &#39;static&#39; // 打包到dist下面的static
}]),</code></pre><h1 id="webpack打包css"><a href="#webpack打包css" class="headerlink" title="webpack打包css"></a>webpack打包css</h1><pre><code class="bash">npm install --save-dev style-loader css-loader</code></pre>
<pre><code class="diff">  const path = require(&#39;path&#39;);

  module.exports = {
   module: {
     rules: [
       {
        test: /\.css$/,
        use: [
          &#39;style-loader&#39;,
          &#39;css-loader&#39;
        ]
      },
     ]
   }
  };</code></pre>
<h1 id="css预处理"><a href="#css预处理" class="headerlink" title="css预处理"></a>css预处理</h1><pre><code>npm i postcss postcss-loader autoprefixer cssnano postcss-cssnext --save-dev  </code></pre><p>在css-loader和style-loader之间使用</p>
<pre><code>{
    loader: &#39;postcss-loader&#39;,
    options: {
        ident: &#39;postcss&#39;,
        plugins: [
           // require(&#39;autoprefixer&#39;)()
            require(&#39;postcss-next&#39;)()
        ]
    }
}</code></pre><p>package.json</p>
<pre><code>&quot;browserslist&quot;: [
    &quot;&gt;= 1%&quot;,
    &quot;last 2 versions&quot;
]</code></pre><h1 id="webpack打包sass"><a href="#webpack打包sass" class="headerlink" title="webpack打包sass"></a>webpack打包sass</h1><pre><code class="diff">npm install --save-dev style-loader css-loader node-sass sass-loader</code></pre>
<pre><code class="diff">const path = require(&#39;path&#39;)
module.exports = {
  module: {
    rules: [
      {
        test: /\.sass$/,
        use: [
          &#39;style-loader&#39;,
          &#39;css-loader&#39;,
          &#39;sass-loader&#39;
        ]
      },
    ]
  }
}
</code></pre>
<h1 id="webpack打包图片"><a href="#webpack打包图片" class="headerlink" title="webpack打包图片"></a>webpack打包图片</h1><pre><code class="bash">npm install --save-dev file-loader</code></pre>
<pre><code class="diff">onst path = require(&#39;path&#39;);

  module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
      filename: &#39;bundle.js&#39;,
      path: path.resolve(__dirname, &#39;dist&#39;)
    },
    module: {
      rules: [
        {
        test: /\.(png|jp?g|gif|svg)$/,
        use: [
          {
            loader: &#39;url-loader&#39;,
            options: {
              limit: 8192, // 小于8192字节的图片打包成base 64图片
              name: &#39;images/[name].[hash:8].[ext]&#39;,
              publicPath: &#39;&#39;
            }
          }
        ]
      },
      ]
    }
  };
</code></pre>
<h1 id="webpack打包字体文件、音频、视频"><a href="#webpack打包字体文件、音频、视频" class="headerlink" title="webpack打包字体文件、音频、视频"></a>webpack打包字体文件、音频、视频</h1><pre><code class="css">@font-face{
  font-family: &#39;myfont&#39;;
  src:url(../fonts/font.ttf) format(&#39;truetype&#39;)
}
body{
  font-family: &#39;myfont&#39;;
  background: hotpink;
}
</code></pre>
<pre><code>npm install url-loader file-loader html-loader -D</code></pre><pre><code class="diff">{
        // 文件依赖配置项——字体图标
        test: /\.(woff|woff2|svg|eot|ttf)$/,
        use: [{
          loader: &#39;file-loader&#39;,
          options: {
            limit: 8192,
            name: &#39;fonts/[name].[ext]?[hash:8]&#39;,
            publicPath: &#39;&#39;
          }
        }]
      },
      {
        // 文件依赖配置项——音频
        test: /\.(wav|mp3|ogg)?$/,
        use: [{
          loader: &#39;file-loader&#39;,
          options: {
            limit: 8192,
            name: &#39;audios/[name].[ext]?[hash:8]&#39;,
            publicPath: &#39;&#39;
          }
        }]
      }, {
        // 文件依赖配置项——视频
        test: /\.(ogg|mpeg4|webm)?$/,
        use: [{
          loader: &#39;file-loader&#39;,
          options: {
            limit: 8192,
            name: &#39;videos/[name].[ext]?[hash:8]&#39;,
            publicPath: &#39;&#39;
          }
        }]
      }
    ]
  },
</code></pre>
<h1 id="webpack生成html"><a href="#webpack生成html" class="headerlink" title="webpack生成html"></a>webpack生成html</h1><pre><code class="bash">npm install --save-dev html-webpack-plugin</code></pre>
<pre><code class="diff">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
+   plugins: [
+     new HtmlWebpackPlugin({
+       title: &#39;Output Management&#39;，
+        template: &#39;index.html&#39;
+     })
+   ],
</code></pre>
<p>如果你想要了解更多 <code>HtmlWebpackPlugin</code> 插件提供的全部功能和选项，那么你就应该多多熟悉 <a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener"><code>HtmlWebpackPlugin</code></a> 仓库。</p>
<p>使用自己的文件做为模版：</p>
<pre><code class="diff">+   plugins: [
+     new HtmlWebpackPlugin({
+       template: &#39;./public/index.html&#39;
+     })
+   ],
</code></pre>
<h1 id="webpack清理dist"><a href="#webpack清理dist" class="headerlink" title="webpack清理dist"></a>webpack清理dist</h1><ul>
<li>参照官网</li>
</ul>
<p><a href="https://webpack.js.org/guides/output-management/#cleaning-up-the-dist-folder" target="_blank" rel="noopener">https://webpack.js.org/guides/output-management/#cleaning-up-the-dist-folder</a></p>
<pre><code class="bash">npm install clean-webpack-plugin --save-dev</code></pre>
<pre><code class="diff">+ const {CleanWebpackPlugin} = require(&#39;clean-webpack-plugin&#39;);</code></pre>
<pre><code class="diff">    plugins: [
+     new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        title: &#39;Output Management&#39;
      })
    ],

    //new CleanWebpackPlugin([&#39;dist&#39;])</code></pre>
<h1 id="webpack-babel介绍"><a href="#webpack-babel介绍" class="headerlink" title="webpack-babel介绍"></a>webpack-babel介绍</h1><ul>
<li>目前部分浏览器和 Node.js 已经支持 ES6，但由于它们对 ES6 所有的标准支持不全，这导致在开发中不敢全面地使用 ES6。</li>
<li>Babel 是一个 JavaScript 编译器，能将 ES6 语法转为 ES5 语法，让你使用最新的语言特性而不用担心兼容性问题，把采用 ES6 编写的代码转换成目前已经支持良好的 ES5 代码。</li>
<li>官网：<a href="https://babeljs.io/" target="_blank" rel="noopener">https://babeljs.io/</a></li>
</ul>
<h1 id="webpack-babel使用"><a href="#webpack-babel使用" class="headerlink" title="webpack-babel使用"></a>webpack-babel使用</h1><pre><code class="bash">npm install -D babel-loader @babel/core @babel/preset-env </code></pre>
<pre><code class="javascript">module: {
  rules: [
    {
      test: /\.m?js$/,
      exclude: /(node_modules|bower_components)/,
      use: {
        loader: &#39;babel-loader&#39;,
        options: {
          presets: [&#39;@babel/preset-env&#39;]
        }
      }
    }
  ]
}
</code></pre>
<p>以上操作是语法解析，但是ES6还更新了一些高阶函数。</p>
<pre><code class="bahs">npm install --save @babel/polyfill</code></pre>
<p>使用：优先加载</p>
<pre><code class="js">import &quot;@babel/polyfill&quot;;</code></pre>
<p>或者：</p>
<pre><code class="js">module.exports = {
  entry: [&quot;@babel/polyfill&quot;, &quot;./src/index.js&quot;],
};</code></pre>
<h1 id="局部垫片（选用）"><a href="#局部垫片（选用）" class="headerlink" title="局部垫片（选用）"></a>局部垫片（选用）</h1><p>不希望污染全局变量</p>
<pre><code>npm i babel-plugin-transform-runtime --save-dev
npm i babel-runtime --save
npm i @babel/plugin-transform-runtime --save-dev
npm i @babel/runtime --save</code></pre><p>.babelrc</p>
<pre><code>{
    &quot;presets&quot;: [
        [&quot;@babel/preset-env&quot;. {
            &quot;targets&quot;: {
            &quot;browsers&quot;: [&quot;last 2 versions&quot;]
            }
        }]
    ],
    &quot;plugins&quot;: [&quot;@babel/transform-runtime&quot;]
}</code></pre><h1 id="webpack-sourceMap"><a href="#webpack-sourceMap" class="headerlink" title="webpack-sourceMap"></a>webpack-sourceMap</h1><p>为了更容易地追踪错误和警告，JavaScript 提供了 <a href="http://blog.teamtreehouse.com/introduction-source-maps" target="_blank" rel="noopener">source map</a> 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 <code>b.js</code>，source map 就会明确的告诉你。</p>
<pre><code class="diff">+   devtool: &#39;inline-source-map&#39;,
    plugins:
</code></pre>
<h1 id="webpack-watch监听"><a href="#webpack-watch监听" class="headerlink" title="webpack-watch监听"></a>webpack-watch监听</h1><p>我们添加一个用于启动 webpack watch mode 的 npm scripts：</p>
<pre><code class="diff">    &quot;scripts&quot;: {
      &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
+     &quot;watch&quot;: &quot;webpack --watch&quot;,
      &quot;build&quot;: &quot;webpack&quot;
    },
</code></pre>
<p>唯一的缺点是，为了看到修改后的实际效果，你需要刷新浏览器。如果能够自动刷新浏览器就更好了，因此接下来我们会尝试通过 <code>webpack-dev-server</code> 实现此功能。</p>
<h1 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h1><p><code>webpack-dev-server</code> 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading),自动刷新浏览器进行实时的预览。</p>
<pre><code class="bash">npm install --save-dev webpack-dev-server</code></pre>
<pre><code class="diff">    devtool: &#39;inline-source-map&#39;,
+   devServer: {
+     contentBase: &#39;./dist&#39;
+   },
</code></pre>
<p><strong>package.json</strong></p>
<pre><code class="diff">    &quot;scripts&quot;: {
+     &quot;dev&quot;: &quot;webpack-dev-server --open&quot;,
</code></pre>
<p>执行：</p>
<pre><code class="bash">npm run dev</code></pre>
<ul>
<li>不会把资源打包到磁盘中，存储在内存中。读取更快。</li>
</ul>
<h1 id="webpack热更新"><a href="#webpack热更新" class="headerlink" title="webpack热更新"></a>webpack热更新</h1><ul>
<li>实现浏览器不刷新，更新打包后的结果，默认对js不生效，对样式，vue组件生效。</li>
</ul>
<pre><code class="diff">+ const webpack = require(&#39;webpack&#39;);

  module.exports = {
    devtool: &#39;inline-source-map&#39;,
    devServer: {
      contentBase: &#39;./dist&#39;,
+     hot: true
    },
    plugins: [
      new CleanWebpackPlugin([&#39;dist&#39;]),
      new HtmlWebpackPlugin({
        title: &#39;模块热替换&#39;
      }),
+     new webpack.HotModuleReplacementPlugin()
    ],
</code></pre>
<h1 id="webpack路径别名"><a href="#webpack路径别名" class="headerlink" title="webpack路径别名"></a>webpack路径别名</h1><pre><code class="js">  resolve: {
    alias: {
      &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;)
    }
  },
</code></pre>
<h1 id="webpack文件后缀"><a href="#webpack文件后缀" class="headerlink" title="webpack文件后缀"></a>webpack文件后缀</h1><pre><code class="diff">  resolve: {
    alias: {
      &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;)
    },
+    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;, &#39;.css&#39;]
  },
</code></pre>
<h1 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h1><pre><code>entry: {
    &#39;vendor&#39;: [&#39;lodash&#39;]
}</code></pre><pre><code>plugin: [
 new webpack.optimize.CommonsChunkPlugin({
        name: &#39;common&#39;,
        minChunks: 2,
        chunks: [&#39;pageA&#39;, &#39;pageB&#39;]
    }),
    new webpack.optimize.CommonsChunkPlugin({
        name: &#39;vendor&#39;,
        minChunks: Infinity
    }),
    new webpack.optimize.CommonsChunkPlugin({
        name: &#39;manifest&#39;,
        minChunks: Infinity
    })
]</code></pre><pre><code>new webpack.optimize.CommonsChunkPlugin({
        async: &#39;async-common&#39;,
        children: true
        minChunks: 2
    }),
new webpack.optimize.CommonsChunkPlugin({
        names: [&#39;vendor&#39;, &#39;manifest&#39;],
        minChunks: Infinity
    })</code></pre><h1 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h1><p>打包</p>
<pre><code class="bash">npm run build</code></pre>
<p>部署（dist目录代码）</p>
<p>不同的后台所部署的服务器不一样。</p>
<p>问题：首屏加载慢（spa网站通病）</p>
<ul>
<li>chunk-vendors-xxxxxx.js   所有第三方模块打包文件    <strong>1867kb</strong></li>
<li>app.xxxxx.js  所有自己模块打包文件</li>
<li>chunk-vendors-xxxxxx.css  所有第三方css打包文件</li>
<li>app.xxxxx.css 所有自己css打包文件</li>
</ul>
<p>方案：按需加载（路由懒加载）</p>
<pre><code class="js">// const Foo = () =&gt; import(&#39;./Foo.vue&#39;) 路由懒加载  将代码分块

const Login = () =&gt; import(&#39;@/views/login&#39;)
const Home = () =&gt; import(&#39;@/views/home&#39;)
const Welcome = () =&gt; import(&#39;@/views/welcome&#39;)
const NotFound = () =&gt; import(&#39;@/views/404&#39;)
const Test = () =&gt; import(&#39;@/views/test&#39;)
const Article = () =&gt; import(&#39;@/views/article&#39;)
const Image = () =&gt; import(&#39;@/views/image&#39;)
const Publish = () =&gt; import(&#39;@/views/publish&#39;)
const Comment = () =&gt; import(&#39;@/views/comment&#39;)
const Setting = () =&gt; import(&#39;@/views/setting&#39;)
const Fans = () =&gt; import(&#39;@/views/fans&#39;)</code></pre>
<h1 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h1><ul>
<li>打包后个别块代码，还是体积较大，因为依赖一些较大的第三方包。</li>
<li>将第三方包，分割出去，降低打包代码体积。<ul>
<li>使用cdn引入方式（script标签引入其他服务器资源）<ul>
<li>cdn是提供前端资源的网站  例如 echarts</li>
</ul>
</li>
<li>排除对应的包的导入<ul>
<li>注释 import echarts from ‘echarts’   不建议使用</li>
<li>配置webpack排除这些包不去打包。</li>
</ul>
</li>
<li>才能在打包降低体积</li>
</ul>
</li>
</ul>
<p>具体配置：</p>
<p>public/index.html</p>
<pre><code class="html">&lt;script src=&quot;https://cdn.bootcss.com/echarts/4.3.0-rc.1/echarts.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>vue.config.js</p>
<pre><code class="js">// 进行vue-cli配置
// vue-cli配置实现了部分webpack的配置
module.exports = {
  // 覆盖webpack的配置选项
  configureWebpack: {
    externals: {
      // key 包名 value 暴露全局的变量名
      echarts: &#39;echarts&#39;
    }
  }
}
</code></pre>
<h1 id="生产环境构建"><a href="#生产环境构建" class="headerlink" title="生产环境构建"></a>生产环境构建</h1><pre><code>npm install --save-dev webpack-merge</code></pre><pre><code>- |- webpack.config.js
+ |- webpack.common.js
+ |- webpack.dev.js
+ |- webpack.prod.js</code></pre><p>webpack.common.js</p>
<pre><code>+ const path = require(&#39;path&#39;);
+ const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);
+ const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
+
+ module.exports = {
+   entry: {
+     app: &#39;./src/index.js&#39;
+   },
+   plugins: [
+     new CleanWebpackPlugin([&#39;dist&#39;]),
+     new HtmlWebpackPlugin({
+       title: &#39;Production&#39;
+     })
+   ],
+   output: {
+     filename: &#39;[name].bundle.js&#39;,
+     path: path.resolve(__dirname, &#39;dist&#39;)
+   }
+ };</code></pre><p>webpack.dev.js</p>
<pre><code>+ const merge = require(&#39;webpack-merge&#39;);
+ const common = require(&#39;./webpack.common.js&#39;);
+
+ module.exports = merge(common, {
+   devtool: &#39;inline-source-map&#39;,
+   devServer: {
+     contentBase: &#39;./dist&#39;
+   }
+ });</code></pre><p>webpack.prod.js</p>
<pre><code> const merge = require(&#39;webpack-merge&#39;);
 const UglifyJSPlugin = require(&#39;uglifyjs-webpack-plugin&#39;);
 const common = require(&#39;./webpack.common.js&#39;);
 const webpack = require(&#39;webpack&#39;)  //指定环境

  module.exports = merge(common, {
+   devtool: &#39;source-map&#39;,
    plugins: [
+     new UglifyJSPlugin({
+       sourceMap: true
+     }),
    new webpack.DefinePlugin({
+       &#39;process.env.NODE_ENV&#39;: JSON.stringify(&#39;production&#39;)
+     })
    ]
  });</code></pre><p><strong>package.json</strong></p>
<pre><code>-     &quot;start&quot;: &quot;webpack-dev-server --open&quot;,
+     &quot;start&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;,
-     &quot;build&quot;: &quot;webpack&quot;
+     &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;</code></pre><h1 id="生产环境代码压缩"><a href="#生产环境代码压缩" class="headerlink" title="生产环境代码压缩"></a>生产环境代码压缩</h1><p>css  js 压缩</p>
<pre><code>npm i mini-css-extract-plugin uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin -D</code></pre><pre><code>修改 webpack.prod.conf.js 增加如下配置

const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)
const UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)
const OptimizeCSSAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)

//例
{
    test: /\.css$/,
    use: [
        MiniCssExtractPlugin.loader,
        {
            loader: &#39;css-loader&#39;
        },{
            loader: &#39;postcss-loader&#39;,
            options: {
                sourceMap: true,
                config: {
                    path: &#39;postcss.config.js&#39;
                }
            }
        }
    ]
},

plugin: {
    new MiniCssExtractPlugin({
        filename: &quot;static/css/[name].[hash].css&quot;,
        chunkFilename: &quot;static/css/[name].[hash].css&quot;
    })
}
optimization: {
    minimizer: [ // 用于配置 minimizers 和选项
        new UglifyJsPlugin({
            cache: true,
            parallel: true,
            sourceMap: true // set to true if you want JS source maps
        }),
        new OptimizeCSSAssetsPlugin({})
    ]
},</code></pre><p>html压缩   修改<code>html-webpack-plugin</code> 的配置</p>
<pre><code>new HtmlWebpackPlugin({
    filename: &#39;index.html&#39;,
    template: path.join(__dirname, &#39;./public/index.html&#39;),
    minify:{
        removeRedundantAttributes:true, // 删除多余的属性
        collapseWhitespace:true, // 折叠空白区域
        removeAttributeQuotes: true, // 移除属性的引号
        removeComments: true, // 移除注释
        collapseBooleanAttributes: true // 省略只有 boolean 值的属性值 例如：readonly checked
    },
    title:&#39;webpack-主页&#39;,
    favicon:&#39;&#39;
})</code></pre><h1 id="shimming-全局变量"><a href="#shimming-全局变量" class="headerlink" title="shimming 全局变量"></a>shimming 全局变量</h1><h1 id="使用middleware搭建开发环境"><a href="#使用middleware搭建开发环境" class="headerlink" title="使用middleware搭建开发环境"></a>使用middleware搭建开发环境</h1><pre><code>npm i express opn webpack-dev-middleware webpack-hot-middleware http-proxy-middleware connect-history-api-fallback --save-dev</code></pre><p>在build目录下建server.js</p>
<pre><code>const express = require(&#39;express&#39;)
const webpack = require(&#39;webpack&#39;)
const opn = require(&#39;opn&#39;)
const app = express()
const port = 3000

const webpackDevMiddleware = require(&#39;webpack-dev-middleware&#39;)
const webpackHotMiddleware = require(&#39;webpack-hot-middleware&#39;)
const proxyMiddelware = require(&#39;proxy-middleware&#39;)
const historyApiFallback = require(&#39;history-api-fallback&#39;)

const config = require(&#39;./webpack.common.conf&#39;)(&#39;development&#39;)
const compiler = webpack(config)

const proxyTable = require(&#39;./proxy&#39;)
for(let context in proxyTable) {
    app.use(proxyMiddleware(context, proxyTable[context]))
}
app.use(historyFallback(require(&#39;./historyfallback&#39;)))

app.use(wwebpackDevMiddleware(compiler), {
    publicPath: config.output.publicPath     
})
app.use(webpackHotMiddleware(complier))

app.listen(port, () =&gt; { 
    console.log(&#39;success listen to &#39;+ port)
    opn(&#39;http://localhost:&#39; + port)
})</code></pre><p>build/proxy.js</p>
<pre><code>module.exports = {

}</code></pre><p>build/historyfallback.js</p>
<pre><code>module.exports = {

}</code></pre><p>在package.json修改启动</p>
<pre><code>&quot;scripts&quot;: {
    &quot;start&quot;: &quot;node build/server.js&quot;
}</code></pre><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><p>webpack.config.js</p>
<pre><code>const path = require(&#39;path&#39;)
const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;)
const webpack = require(&#39;webpack&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;)

module.exports = {
  mode: &#39;development&#39;,
  devtool: &#39;inline-source-map&#39;,
  devServer: {
    contentBase: path.resolve(__dirname, &#39;dist&#39;),
    historyApiFallback: true,
    hot: true,
    port: 8080,
    host: &#39;127.0.0.1&#39;,
    overlay: true
  },
  resolve: {
    alias: {
      &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;)
    },
    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;, &#39;.css&#39;]
  },
  entry: &#39;./src/main.js&#39;,
  output: {
    filename: &#39;js/bundle.js&#39;,
    path: path.resolve(__dirname, &#39;./dist&#39;)
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: &#39;vue-loader&#39;
      },
      {
        test: /\.css$/,
        use: [
          &#39;style-loader&#39;,
          &#39;css-loader&#39;
        ]
      },
      {
        test: /\.sass$/,
        use: [
          &#39;style-loader&#39;,
          &#39;css-loader&#39;,
          &#39;sass-loader&#39;
        ]
      },
      {
        test: /\.(png|jp?g|gif|svg)$/,
        use: [
          {
            loader: &#39;url-loader&#39;,
            options: {
              limit: 8192, // 小于8192字节的图片打包成base 64图片
              name: &#39;images/[name].[hash:8].[ext]&#39;,
              publicPath: &#39;&#39;
            }
          }
        ]
      },
      {
        // 文件依赖配置项——字体图标
        test: /\.(woff|woff2|svg|eot|ttf)$/,
        use: [{
          loader: &#39;file-loader&#39;,
          options: {
            limit: 8192,
            name: &#39;fonts/[name].[ext]?[hash:8]&#39;,
            publicPath: &#39;&#39;
          }
        }]
      },
      {
        // 文件依赖配置项——音频
        test: /\.(wav|mp3|ogg)?$/,
        use: [{
          loader: &#39;file-loader&#39;,
          options: {
            limit: 8192,
            name: &#39;audios/[name].[ext]?[hash:8]&#39;,
            publicPath: &#39;&#39;
          }
        }]
      }, {
        // 文件依赖配置项——视频
        test: /\.(ogg|mpeg4|webm)?$/,
        use: [{
          loader: &#39;file-loader&#39;,
          options: {
            limit: 8192,
            name: &#39;videos/[name].[ext]?[hash:8]&#39;,
            publicPath: &#39;&#39;
          }
        }]
      }
    ]
  },
  plugins: [
    // 请确保引入这个插件！
    new HtmlWebpackPlugin({
      template: &#39;./public/index.html&#39;
    }),
    new CopyWebpackPlugin([{
      from: path.resolve(__dirname, &#39;./public/static&#39;), // 打包的静态资源目录地址
      to: &#39;static&#39; // 打包到dist下面的static
    }]),
    new VueLoaderPlugin(),
    new webpack.HotModuleReplacementPlugin()
  ]
}</code></pre><p>package.json</p>
<pre><code>&quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vue-cli-service serve --config webpack.config.js --hot --inline --progress --open&quot;,
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;watch&quot;: &quot;webpack --watch&quot;
}</code></pre><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src="/2020/03/13/webpack/webpack.png" alt></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>node写接口</title>
    <url>/2020/03/13/node/node/</url>
    <content><![CDATA[<h1 id="安装express-mysql-body-parser"><a href="#安装express-mysql-body-parser" class="headerlink" title="安装express  mysql  body-parser"></a>安装express  mysql  body-parser</h1><pre><code>npm i express mysql body-parser</code></pre><h1 id="创建db-js"><a href="#创建db-js" class="headerlink" title="创建db.js"></a>创建db.js</h1><pre><code>module.exports = (sql, values, cb) =&gt; {
    const mysql = require(&#39;mysql&#39;)
    const conn = mysql.createConnection({
        host: &#39;localhost&#39;,
        port: &#39;3306&#39;,
        user: &#39;root&#39;,
        password: &#39;&#39;,
        database: &#39;hero&#39;,
        multipleStatements: true
    })
    conn.connect()
    conn.query(sql, values, cb)
    conn.end()
}</code></pre><h1 id="创建app-js"><a href="#创建app-js" class="headerlink" title="创建app.js"></a>创建app.js</h1><pre><code>// 创建web服务器
const express = require(&#39;express&#39;);
const app = express();
app.listen(3000, () =&gt; console.log(&#39;服务器启动了&#39;));

// 使用中间件，处理文件资源
app.use(express.static(&#39;manager&#39;));
app.use(&#39;/uploads&#39;, express.static(__dirname + &#39;/uploads&#39;));

// 处理 ‘x-www-form-urlencoded’ 编码格式的POST请求体 （把浏览器提交的数据放到 req.body中）
const bodyParser = require(&#39;body-parser&#39;);
app.use(bodyParser.urlencoded({extended: false}));

const db = require(&#39;./db.js&#39;);
///////////////////////////// 下面是接口 ////////////////////////////////////////
// app.get(&#39;/time&#39;, (req, res) =&gt; {
//     res.send(Date.now() + &#39;&#39;);
// });

// 1. 完成获取英雄的接口
app.get(&#39;/getHeroes&#39;, (req, res) =&gt; {
    // 接收前端传递过来的page
    let page = req.query.page || 1; // page表示页码
    let pageNum = 5; // 表示每页显示多少条
    let sql = &#39;select * from heroes limit &#39; + (page-1) * pageNum + &#39;,&#39; + pageNum;
    sql += &#39;;select count(*) c from heroes&#39;;
    db(sql, null, (err, result) =&gt; {
        if (err) throw err;
        console.log(result);
        res.send({
            data: result[0],
            pageTotal: Math.ceil(result[1][0].c / pageNum)
        });
        // res.send(result);
    });
});


// 2. 完成添加英雄的接口
// 加载multer
const multer = require(&#39;multer&#39;);
// 配置multer
const upload = multer({ dest: &#39;uploads/&#39;});

app.post(&#39;/addHero&#39;, upload.single(&#39;heroIcon&#39;), (req, res) =&gt; {
    // console.log(req.body); 
    // console.log(req.file);
    // 写SQL，完成添加入库
    let sql = &#39;insert into heroes set ?&#39;;
    let values = {
        // 字段： 值
        name: req.body.heroName,
        nickname: req.body.heroNickName,
        skill: req.body.skillName,
        file: req.file.path
    };
    db(sql, values, (err, result) =&gt; {
        if (err) {
            // send方法，它会将对象自动转成json格式并响应
            res.send({code: 201, message: &#39;添加失败&#39;});
        } else {
            res.send({code: 200, message: &#39;添加成功&#39;});
        }
    });
});


// 3. 根据id，获取一个英雄
app.get(&#39;/getHeroById&#39;, (req, res) =&gt; {
    // 获取url上的id参数
    // req.query -- 可以获取到url上所有的参数。这是express提供的一个属性
    let id = req.query.id;
    if (id == &#39;&#39; || isNaN(id)) {
        res.send(&#39;参数错误&#39;);
        return;
    }
    db(&#39;select * from heroes where id=?&#39;, id, (err, result) =&gt; {
        if (err) throw err;
        res.send(result[0]);
    });
});

// 4. 更新的接口
app.post(&#39;/updateHero&#39;, upload.single(&#39;heroIcon&#39;), (req, res) =&gt; {
    // console.log(req.body); 
    // console.log(req.file);
    // 写SQL，完成添加入库
    let sql = &#39;update heroes set ? where id = ?&#39;;
    let values = {
        // 字段： 值
        name: req.body.heroName,
        nickname: req.body.heroNickName,
        skill: req.body.skillName
    };
    // 单独设置文件
    // console.log(req.file); // 如果没有选择图片，req.file为undefined
    if (req.file !== undefined) {
        // 说明此次更新了头像
        values.file = req.file.path;
    }
    // return;
    db(sql, [values, req.body.id], (err, result) =&gt; {
        if (err) {
            // send方法，它会将对象自动转成json格式并响应
            res.send({code: 201, message: &#39;更新失败&#39;});
        } else {
            res.send({code: 200, message: &#39;更新成功&#39;});
        }
    });
});


// 5. 删除英雄的接口
app.get(&#39;/deleteHero&#39;, (req, res) =&gt; {
    // 获取url上的id
    // console.log(req.query);
    let id = req.query.id;
    if (id == &#39;&#39; || isNaN(id)) {
        res.send(&#39;参数错误&#39;);
        return;
    }
    // 完成删除
    db(&#39;delete from heroes where id = ?&#39;, id, (err, result) =&gt; {
        if (err) {
            res.send({code: 201, message: &#39;删除失败&#39;});
        } else {
            res.send({code: 200, message: &#39;删除成功&#39;});
        }
    });
});</code></pre>]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Element使用i18n国际化</title>
    <url>/2020/03/13/vue/i18n/</url>
    <content><![CDATA[<h1 id="安装i18n-elementUI"><a href="#安装i18n-elementUI" class="headerlink" title="安装i18n+elementUI"></a>安装i18n+elementUI</h1><pre><code>npm i vue-i18n element-ui</code></pre><h1 id="在main-js中导入"><a href="#在main-js中导入" class="headerlink" title="在main.js中导入"></a>在main.js中导入</h1><pre><code>import i18n from &#39;./i18n.js&#39;
import ElementUI from &#39;element-ui&#39;
import &#39;element-ui/lib/theme-chalk/index.css&#39;

Vue.use(ElementUI)

Vue.config.productionTip = false

new Vue({
  i18n,
  router,
  render: h =&gt; h(App)
}).$mount(&#39;#app&#39;)</code></pre><h2 id="在static文件夹下创建config-js-en-js-zh-js-index-js-文件"><a href="#在static文件夹下创建config-js-en-js-zh-js-index-js-文件" class="headerlink" title="在static文件夹下创建config.js     en.js   zh.js    index.js  文件"></a>在static文件夹下创建config.js     en.js   zh.js    index.js  文件</h2><h2 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a>config.js</h2><pre><code>window.apiConfig = {
  language: &#39;zh-CN&#39;
}</code></pre><h2 id="en-js"><a href="#en-js" class="headerlink" title="en.js"></a>en.js</h2><pre><code>var en = {
  main: {
    Main_Title: &#39;shopping&#39;
  }
}</code></pre><h2 id="zh-js"><a href="#zh-js" class="headerlink" title="zh.js"></a>zh.js</h2><pre><code>var zh = {
  main: {
    Main_Title: &#39;购物&#39;
  }
}</code></pre><h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><pre><code>import en from &#39;./en&#39;

import zh from &#39;./zh&#39;

export default {

  en: en,

  zh: zh

}</code></pre><h2 id="static文件下创建css文件夹"><a href="#static文件下创建css文件夹" class="headerlink" title="static文件下创建css文件夹"></a>static文件下创建css文件夹</h2><h3 id="en-css"><a href="#en-css" class="headerlink" title="en.css"></a>en.css</h3><pre><code>.login-container .login_top .login_input .login_title {
    position: absolute;
    top: 52%;
    left: 10%;
    font-size: 26px;
    color: #017fba;
}</code></pre><h3 id="zh-css"><a href="#zh-css" class="headerlink" title="zh.css"></a>zh.css</h3><pre><code>.UserRightsManagement .el-form .usersDataDiv .contentDiv .silde-panel .content .power-sort .el-checkbox {
    width: 40%;
    min-width: 200px;

  }</code></pre><h1 id="在与main-js同级创建i18n-js"><a href="#在与main-js同级创建i18n-js" class="headerlink" title="在与main.js同级创建i18n.js"></a>在与main.js同级创建i18n.js</h1><pre><code>import Vue from &#39;vue&#39;
import VueI18n from &#39;vue-i18n&#39;
import locale from &#39;element-ui/lib/locale&#39;
import zhLocale from &#39;element-ui/lib/locale/lang/zh-CN&#39;
import enLocale from &#39;element-ui/lib/locale/lang/en&#39;

Vue.use(VueI18n)
var message = {
  &#39;en-US&#39;: Object.assign(en, enLocale),
  &#39;zh-CN&#39;: Object.assign(zh, zhLocale)
}
const i18n = new VueI18n({
  locale: window.apiConfig.language,
  message
})

locale.i18n((key, value) =&gt; i18n.t(key, value))
export default i18n
</code></pre><h1 id="在public-index-html文件引入"><a href="#在public-index-html文件引入" class="headerlink" title="在public/index.html文件引入"></a>在public/index.html文件引入</h1><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= BASE_URL %&gt;static/config.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/zh.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/en.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code>&lt;script&gt;
      document.oncontextmenu = function () {  //取消鼠标右键
        return false;
      };
      //禁用开发者工具F12
      document.onkeydown = function () {
        if (window.event &amp;&amp; window.event.keyCode == 123) {
          event.keyCode = 0;
          event.returnValue = false;
          return false;
        }
      }
      var lang = window.apiConfig.language;
      var linkNode = document.createElement(&quot;link&quot;);
      linkNode.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;);
      linkNode.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
      if (lang == &quot;es&quot;) {
        linkNode.setAttribute(&quot;href&quot;, &quot;./static/css/en.css&quot;);
      } else if (lang == &quot;zh-CN&quot;) {
        linkNode.setAttribute(&quot;href&quot;, &quot;./static/css/zh.css&quot;);
      }
      document.head.appendChild(linkNode)
    &lt;/script&gt;</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre><code>{{$t('main.Main_Title')}}</code></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>token</title>
    <url>/2020/03/11/vue/token/</url>
    <content><![CDATA[<h1 id="存在本地"><a href="#存在本地" class="headerlink" title="存在本地"></a>存在本地</h1><p>utils/auth.js</p>
<pre><code>const USER_KEY = &#39;123&#39;
export const getUser = () =&gt; {
  return JSON.parse(window.localStorage.getItem(USER_KEY) || &#39;{}&#39;)
}
export const setUser = (user) =&gt; {
  window.localStorage.setItem(USER_KEY, JSON.stringify(user))
}
export const delUser = () =&gt; {
  window.localStorage.removeItem(USER_KEY)
}
</code></pre><h1 id="存在axios"><a href="#存在axios" class="headerlink" title="存在axios"></a>存在axios</h1><p>store.js</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
import * as auth from &#39;@/utils/auth&#39;

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    user: auth.getUser()
  },
  mutations: {
    setUser (state, user) {
      state.user = user
      auth.setUser(user)
    },
    delUser (state) {
      state.user = {}
      auth.delUser()
    }
  },
  actions: {
  }
})
</code></pre><h1 id="封装request"><a href="#封装request" class="headerlink" title="封装request"></a>封装request</h1><p>utils/request.js</p>
<pre><code>import axios from &#39;axios&#39;
import JSONBIG from &#39;json-bigint&#39;
import store from &#39;@/store&#39;
import router from &#39;@/router&#39;

const instance = axios.create({
  baseURL: &#39;http://ttapi.research.cn/&#39;,
  transefromResponse: [(data) =&gt; {
    try {
      return JSONBIG.parse(data)
    } catch (e) {
      return data
    }
  }]
})

instance.interceptors.request.use(config =&gt; {
  if (store.state.user.token) {
    config.headers.Authorization = `Bearer ${store.state.user.token}`
  }
  return config
}, err =&gt; Promise.reject(err))

instance.interceptors.response.use(res =&gt; {
  try {
    return res.data.data
  } catch (e) {
    return res.data
  }
}, async err =&gt; {
  if (err.response &amp;&amp; err.response.status === 401) {
    const user = store.state.user
    const login = { path: &#39;/login&#39;, query: { redirect: router.currentRoute.path } }
    if (!user.token || !user.refresh_token) {
      router.push(login)
      // return
      return Promise.reject(err)
    }
    try {
      const { data: { data } } = await axios({
        url: &#39;http://ttapi.research.itcast.cn/app/v1_0/authorizations&#39;,
        method: &#39;put&#39;,
        headers: {
          Authorization: `Bearer ${user.refresh_token}`
        }
      })
      store.commit(&#39;setUser&#39;, {
        token: data.token,
        refresh_token: user.refresh_token
      })
      return instance(err.config)
    } catch (e) {
      store.commit(&#39;delUser&#39;)
      router.push(login)
      // 出错，要抛出错误，不抛出不会阻碍程序运行
      return Promise.reject(err)
    }
  }
  return Promise.reject(err)
})

export default (url, method, data) =&gt; {
  return instance({
    url,
    method,
    [method.toLowerCase() === &#39;get&#39; ? &#39;params&#39; : &#39;data&#39;]: data
  })
}
</code></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>正则</title>
    <url>/2020/03/09/problem/%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<h1 id="正则匹配特殊字符"><a href="#正则匹配特殊字符" class="headerlink" title="正则匹配特殊字符"></a>正则匹配特殊字符</h1><pre><code>var pattern = new RegExp(
          &quot;[`~!@#$^&amp;*()=|{}&#39;:;&#39;,\\[\\].&lt;&gt;/?~@#￥……&amp;*（）——|{}【】‘；：”“&#39;。，、？]&quot;
        );
 if (pattern.test(value)) {}

 或 value.match(pattern)</code></pre><h1 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h1><pre><code>let pattern = /^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.[a-zA-Z0-9]{2,6}$/</code></pre><h1 id="电话"><a href="#电话" class="headerlink" title="电话"></a>电话</h1><pre><code>let pattern = /^[1][3-8][0-9]{9}$/</code></pre><h1 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h1><pre><code>1 数字：^[0-9]*$ 

2 n位的数字：^\d{n}$

3 至少n位的数字：^\d{n,}$ 

4 m-n位的数字：^\d{m,n}$ 

5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 

6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 

7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 

8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 

9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$

12 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$

13 非负整数：^\d+$ 或 ^[1-9]\d*|0$

14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$

15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$

16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$

19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></pre><h1 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h1><pre><code>1 汉字：^[\u4e00-\u9fa5]{0,}$ 

2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 

3 长度为3-20的所有字符：^.{3,20}$ 

4 由26个英文字母组成的字符串：^[A-Za-z]+$ 

5 由26个大写英文字母组成的字符串：^[A-Z]+$ 

6 由26个小写英文字母组成的字符串：^[a-z]+$ 

7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 

8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 

9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$

10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$

11 可以输入含有^%&amp;&#39;,;=?$\&quot;等字符：[^%&amp;&#39;,;=?$\x22]+

12 禁止输入含有~的字符：[^~\x22]+</code></pre><h1 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h1><pre><code>1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 

2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 

3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 

4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 

5 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$  

6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 

7 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 

8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 

9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

12 日期格式：^\d{4}-\d{1,2}-\d{1,2}

13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$

14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

15 钱的输入格式：

16 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$

17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$

18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$

19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$

20 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]{2})?$

21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$

22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$

23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$

24 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里

25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$

26 中文字符的正则表达式：[\u4e00-\u9fa5]

27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))

28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)

29 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)

32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) 33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) 34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) </code></pre>]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE打印功能</title>
    <url>/2020/02/27/vue/vue-print/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>npm install vue-print-nb --save</code></pre><h1 id="在main-js文件中引入"><a href="#在main-js文件中引入" class="headerlink" title="在main.js文件中引入"></a>在main.js文件中引入</h1><pre><code>import Print from &#39;vue-print-nb&#39;
Vue.use(Print);</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre><code>&lt;div id=&quot;printTest&quot;&gt;　&lt;/div&gt;
&lt;button v-print=&quot;&#39;#printTest&#39;&quot;&gt;打印&lt;/button&gt;</code></pre><h1 id="如需通过链接地址打印"><a href="#如需通过链接地址打印" class="headerlink" title="如需通过链接地址打印"></a>如需通过链接地址打印</h1><pre><code>window.location.href = 地址</code></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>element表格导出功能</title>
    <url>/2020/02/27/vue/elemenet-print/</url>
    <content><![CDATA[<h1 id="安包"><a href="#安包" class="headerlink" title="安包"></a>安包</h1><pre><code>npm install --save xlsx file-saver</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="给表格添加一个id-table-export"><a href="#给表格添加一个id-table-export" class="headerlink" title="给表格添加一个id     table-export"></a>给表格添加一个id     table-export</h2><h2 id="引入导出表格依赖"><a href="#引入导出表格依赖" class="headerlink" title="引入导出表格依赖"></a>引入导出表格依赖</h2><pre><code>import FileSaver from &quot;file-saver&quot;;
import XLSX from &quot;xlsx&quot;;</code></pre><h2 id="data声明存表格内容的数据tableData"><a href="#data声明存表格内容的数据tableData" class="headerlink" title="data声明存表格内容的数据tableData"></a>data声明存表格内容的数据tableData</h2><h2 id="定义导出excel事件"><a href="#定义导出excel事件" class="headerlink" title="定义导出excel事件"></a>定义导出excel事件</h2><pre><code class="xml">exportExcel() {
    /* 从表生成工作簿对象 */
    var wb = XLSX.utils.table_to_book(document.querySelector(&quot;#table-export&quot;));
    /* 获取二进制字符串作为输出 */
    var wbout = XLSX.write(wb, {
    bookType: &quot;xlsx&quot;,
    bookSST: true,
    type: &quot;array&quot;
    });
    try {
    FileSaver.saveAs(
    //Blob 对象表示一个不可变、原始数据的类文件对象。
    //Blob 表示的不一定是JavaScript原生格式的数据。
    //File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。
    //返回一个新创建的 Blob 对象，其内容由参数中给定的数组串联组成。
    new Blob([wbout], { type: &quot;application/octet-stream&quot; }),
    //设置导出文件名称
    &quot;sheetjs.xlsx&quot;
    );
    } catch (e) {
    if (typeof console !== &quot;undefined&quot;) console.log(e, wbout);
    }
return wbout;
        }
    }</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>离线安装node-sass</title>
    <url>/2020/02/21/vue/node-sass/</url>
    <content><![CDATA[<h1 id="离线安装node-sass"><a href="#离线安装node-sass" class="headerlink" title="离线安装node-sass"></a>离线安装node-sass</h1><h2 id="查看服务器的node版本"><a href="#查看服务器的node版本" class="headerlink" title="查看服务器的node版本"></a>查看服务器的node版本</h2><p><code>node -p &quot;[process.platform, process.arch, process.versions.modules].join(&#39;-&#39;)&quot;</code></p>
<h2 id="下载node-sass"><a href="#下载node-sass" class="headerlink" title="下载node-sass"></a>下载node-sass</h2><p>​    去<strong>Github</strong>上下载对象的node-sass版本</p>
<p>​    下载地址：<a href="https://github.com/sass/node-sass/releases" target="_blank" rel="noopener">https://github.com/sass/node-sass/releases</a> </p>
<h2 id="配置离线信息"><a href="#配置离线信息" class="headerlink" title="配置离线信息"></a>配置离线信息</h2><ol>
<li><p>在项目里根目录下新建lib文件夹</p>
</li>
<li><p>将下载的win32-x64-57_binding.node` 复制到lib中</p>
</li>
<li><p>配置package.json中，sass的离线配置</p>
<pre><code class="json">&quot;nodeSassConfig&quot;: {
  &quot;binaryPath&quot;: &quot;./lib/win32-x64-72_binding.node&quot;
}</code></pre>
<h2 id="设置sass路径"><a href="#设置sass路径" class="headerlink" title="设置sass路径"></a>设置sass路径</h2><pre><code>set SASS_BINARY_PATH=D:/nodejs/lib/win32-x64-72_binding.node</code></pre><h2 id="然后安装node-sass模块"><a href="#然后安装node-sass模块" class="headerlink" title="然后安装node-sass模块"></a>然后安装node-sass模块</h2><pre><code>npm i node-sass -D --verbose</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>node-sass</tag>
      </tags>
  </entry>
  <entry>
    <title>echarts</title>
    <url>/2020/01/06/echarts/echarts/</url>
    <content><![CDATA[<pre><code>
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
            &lt;title&gt;
                Document
            &lt;/title&gt;
        &lt;/meta&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;main&quot; style=&quot;width: 1000px;height:600px;&quot;&gt;
        &lt;/div&gt;
        &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.4.0-rc.1/echarts-en.common.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            // 基于准备好的dom，初始化echarts实例
        var chart = echarts.init(document.getElementById(&#39;main&#39;));

        var app = []


        var posList = [
    &#39;left&#39;, &#39;right&#39;, &#39;top&#39;, &#39;bottom&#39;,
    &#39;inside&#39;,
    &#39;insideTop&#39;, &#39;insideLeft&#39;, &#39;insideRight&#39;, &#39;insideBottom&#39;,
    &#39;insideTopLeft&#39;, &#39;insideTopRight&#39;, &#39;insideBottomLeft&#39;, &#39;insideBottomRight&#39;
];

app.configParameters = {
    rotate: {
        min: -90,
        max: 90
    },
    align: {
        options: {
            left: &#39;left&#39;,
            center: &#39;center&#39;,
            right: &#39;right&#39;
        }
    },
    verticalAlign: {
        options: {
            top: &#39;top&#39;,
            middle: &#39;middle&#39;,
            bottom: &#39;bottom&#39;
        }
    },
    position: {
        options: echarts.util.reduce(posList, function (map, pos) {
            map[pos] = pos;
            return map;
        }, {})
    },
    distance: {
        min: 0,
        max: 100
    }
};

app.config = {
    rotate: 90,
    align: &#39;left&#39;,
    verticalAlign: &#39;middle&#39;,
    position: &#39;insideBottom&#39;,
    distance: 15,
    onChange: function () {
        var labelOption = {
            normal: {
                rotate: app.config.rotate,
                align: app.config.align,
                verticalAlign: app.config.verticalAlign,
                position: app.config.position,
                distance: app.config.distance
            }
        };
        myChart.setOption({
            series: [{
                label: labelOption
            }, {
                label: labelOption
            }, {
                label: labelOption
            }, {
                label: labelOption
            }]
        });
    }
};


var labelOption = {
    normal: {
        show: true,
        position: app.config.position,
        distance: app.config.distance,
        align: app.config.align,
        verticalAlign: app.config.verticalAlign,
        rotate: app.config.rotate,
        formatter: &#39;{c}  {name|{a}}&#39;,
        fontSize: 16,
        rich: {
            name: {
                textBorderColor: &#39;#fff&#39;
            }
        }
    }
};

option = {
    color: [&#39;#003366&#39;, &#39;#006699&#39;, &#39;#4cabce&#39;, &#39;#e5323e&#39;],
    tooltip: {
        trigger: &#39;axis&#39;,
        axisPointer: {
            type: &#39;shadow&#39;
        }
    },
    legend: {
        data: [&#39;Forest&#39;, &#39;Steppe&#39;, &#39;Desert&#39;, &#39;Wetland&#39;]
    },
    toolbox: {
        show: true,
        orient: &#39;vertical&#39;,
        left: &#39;right&#39;,
        top: &#39;center&#39;,
        feature: {
            mark: {show: true},
            dataView: {show: true, readOnly: false},
            magicType: {show: true, type: [&#39;line&#39;, &#39;bar&#39;, &#39;stack&#39;, &#39;tiled&#39;]},
            restore: {show: true},
            saveAsImage: {show: true}
        }
    },
    calculable: true,
    xAxis: [
        {
            type: &#39;category&#39;,
            axisTick: {show: false},
            data: [&#39;2012&#39;, &#39;2013&#39;, &#39;2014&#39;, &#39;2015&#39;, &#39;2016&#39;]
        }
    ],
    yAxis: [
        {
            type: &#39;value&#39;
        }
    ],
    series: [
        {
            name: &#39;Forest&#39;,
            type: &#39;bar&#39;,
            barGap: 0,
            label: labelOption,
            data: [320, 332, 301, 334, 390]
        },
        {
            name: &#39;Steppe&#39;,
            type: &#39;bar&#39;,
            label: labelOption,
            data: [220, 182, 191, 234, 290]
        },
        {
            name: &#39;Desert&#39;,
            type: &#39;bar&#39;,
            label: labelOption,
            data: [150, 232, 201, 154, 190]
        },
        {
            name: &#39;Wetland&#39;,
            type: &#39;bar&#39;,
            label: labelOption,
            data: [98, 77, 101, 99, 40]
        }
    ]
};

chart.setOption(option)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>]]></content>
      <categories>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo引用本地图片无法显示</title>
    <url>/2020/01/06/problem/hexoImg/</url>
    <content><![CDATA[<p><strong>hexo引用本地图片无法显示</strong></p>
<ul>
<li>_config.yml文件中修改<code>post_asset_folder: true</code></li>
<li>安装插件<strong>hexo-asset-image</strong></li>
</ul>
<pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><ul>
<li><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p>
<p>hexo-asset-image版本问题，需要3.0以上版本</p>
</li>
</ul>
<pre><code>&#39;use strict&#39;;
var cheerio = require(&#39;cheerio&#39;);

// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string
function getPosition(str, m, i) {
  return str.split(m, i).join(m).length;
}

var version = String(hexo.version).split(&#39;.&#39;);
hexo.extend.filter.register(&#39;after_post_render&#39;, function(data){
  var config = hexo.config;
  if(config.post_asset_folder){
        var link = data.permalink;
    if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)
       var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;
    else
       var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;
    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.
    var endPos = link.lastIndexOf(&#39;/&#39;) + 1;
    link = link.substring(beginPos, endPos);

    var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];
    for(var i = 0; i &lt; toprocess.length; i++){
      var key = toprocess[i];

      var $ = cheerio.load(data[key], {
        ignoreWhitespace: false,
        xmlMode: false,
        lowerCaseTags: false,
        decodeEntities: false
      });

      $(&#39;img&#39;).each(function(){
        if ($(this).attr(&#39;src&#39;)){
            // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.
            var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);
            if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;
               !/^\s*\//.test(src)) {
              // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.
              // In addition, to support multi-level local directory.
              var linkArray = link.split(&#39;/&#39;).filter(function(elem){
                return elem != &#39;&#39;;
              });
              var srcArray = src.split(&#39;/&#39;).filter(function(elem){
                return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;
              });
              if(srcArray.length &gt; 1)
                srcArray.shift();
              src = srcArray.join(&#39;/&#39;);
              $(this).attr(&#39;src&#39;, config.root + link + src);
              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);
            }
        }else{
            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);
            console.info&amp;&amp;console.info($(this));
        }
      });
      data[key] = $.html();
    }
  }
});</code></pre><ul>
<li>hexo new test会生成一个test.md文件与test文件夹，将图片放入text文件夹下</li>
<li>_config.yml修改URL的url为你自己的github仓库 <a href="https://username.github.io" target="_blank" rel="noopener">https://username.github.io</a></li>
<li>在test.md中图片路径改为(编译时会把index.html文件放到test文件夹下，因此图片路径直接引用)</li>
</ul>
<pre><code>![](test.jpg)</code></pre>]]></content>
      <categories>
        <category>hexo问题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo代码高亮</title>
    <url>/2020/01/06/problem/problem/</url>
    <content><![CDATA[<p><strong>hexo代码高亮</strong></p>
<ul>
<li><p>在主题的_config.yml文件中修改highlight为true,可自定义主题</p>
<pre><code>highlight:

 on: true # true开启代码高亮

 lineNum: true # true显示行号

 theme: kimbie-dark</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>hexo问题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>blog搭建</title>
    <url>/2020/01/02/blog/</url>
    <content><![CDATA[<p><strong>1、开始搭建</strong></p>
<p>windows环境搭建</p>
<p>&lt;1&gt;    安装  <code>git+nodejs</code></p>
<p>测试  <code>node -v</code>      <code>git --version</code></p>
<pre><code class="{% asset_img node.png Archer主题页面 %}">{% asset_img node.png Archer主题页面 %}</code></pre>
<p><img src="/2020/01/02/blog/node.png" alt></p>
<p><strong>2、  搭建流程</strong></p>
<ol>
<li>在某个文件夹下  <code>Git Bash Here</code>，输入  <code>npm install -g hexo</code>开始安装</li>
</ol>
<p>完成后输入hexo -v检查</p>
<p><img src="/2020/01/02/blog/hexo-v.png" alt></p>
<ol>
<li>在一个空文件夹下（blog）输入  <code>hexo init</code>  初始化文件夹，若生成以下文件说明安装成功</li>
</ol>
<p><img src="/2020/01/02/blog/test.png" alt></p>
<ol>
<li>输入    <code>hexo g</code>    <code>hexo s</code>    输入    <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>    访问网站</li>
</ol>
<p><img src="/2020/01/02/blog/image-20200102160613245.png" alt></p>
<ol>
<li>更换主题</li>
</ol>
<p>安装hexo主题</p>
<p>例<a href="https://github.com/yelog/hexo-theme-3-hexo.git" target="_blank" rel="noopener">https://github.com/yelog/hexo-theme-3-hexo.git</a></p>
<p><code>git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</code></p>
<p>修改hexo根目录的<code>_config.yml</code></p>
<pre><code class="theme:">theme: 3-hexo</code></pre>
<p>输入  <code>hexo s</code>    刷新浏览器可看到修改后的页面</p>
<p><img src="/2020/01/02/blog/image-20200102161518422.png" alt></p>
<ol>
<li><p>在github创建仓库，仓库名与github账号名一致，命名方式为    <code>username.github.io</code></p>
</li>
<li><p>在根目录下_config.yml文件,添加如下代码</p>
<pre><code>deploy:
  type: git
  repository: https://github.com/zhangxuet/zhangxuet.github.io.git
  branch: master</code></pre></li>
</ol>
<p><strong>3、检查 SSH KEY</strong></p>
<ul>
<li>输入cd ~/.ssh，说明没有SSH KEY</li>
</ul>
<p><img src="/2020/01/02/blog/image-20200102162555031.png" alt></p>
<ul>
<li>添加SSH KEY</li>
</ul>
<p>输入 <code>ssh-keygen -t rsa -C &quot;邮箱名&quot;</code></p>
<p>一直回车</p>
<p><img src="/2020/01/02/blog/image-20200102162912687.png" alt></p>
<ul>
<li>再次输入命令    <code>cd ~/.ssh</code>   <code>ls</code></li>
</ul>
<p><img src="/2020/01/02/blog/image-20200102163014458.png" alt></p>
<ul>
<li>github 设置 SSH KEY</li>
</ul>
<p><img src="/2020/01/02/blog/image-20200102163351752.png" alt></p>
<p><img src="/2020/01/02/blog/image-20200102163427240.png" alt></p>
<ul>
<li>输入  eval “$(ssh-agent -s)”</li>
</ul>
<p>再输入    ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</p>
<p>查看密匙   </p>
<p><img src="/2020/01/02/blog/image-20200102164037200.png" alt></p>
<p><img src="/2020/01/02/blog/image-20200102165043182.png" alt></p>
<p>或输入 cat ~/.ssh/id_rsa.pub 查看</p>
<pre><code class="console">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== schacon@mylaptop.local</code></pre>
<ul>
<li>将id_ssa文件下的所有内容复制到github SSH KEY  ，输入 <code>ssh -T git@github.com</code>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</li>
</ul>
<p><img src="/2020/01/02/blog/image-20200102165517185.png" alt></p>
<ul>
<li>设置账号信息</li>
</ul>
<pre><code>git config --global user.name &quot;zhangxuet&quot;
git config --global user.email &quot;111111@qq.com&quot;</code></pre><ul>
<li>部署到 github，分别输入</li>
</ul>
<pre><code class="js">hexo g         hexo d        hexo s</code></pre>
<p>输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以访问博客（本地）</p>
<p>输入https://用户名.github.io就能访问到你自己的github了</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>工具</title>
    <url>/2020/01/02/resources/index/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>First</title>
    <url>/2019/12/31/First/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>:happy:</p>
<p>:cry:</p>
<p>:sweat:</p>
<p>​     <strong>123</strong></p>
<p><strong>123</strong></p>
<p><code>prinft</code></p>
<pre><code class="html">
&lt;h1&gt;
  hello {{ city }}
&lt;/h1&gt;

&lt;span&gt;
  nihao
&lt;/span&gt;
</code></pre>
123

<blockquote>
<p>1</p>
<blockquote>
<p>2</p>
<blockquote>
<p>3</p>
</blockquote>
</blockquote>
</blockquote>
<p>111</p>
<h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p><code>123</code></p>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p><code>123</code></p>
<h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
